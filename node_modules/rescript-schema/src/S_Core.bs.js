// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

var Obj = {};

var Type = {};

var $$Promise = {};

var Re = {};

var $$Object = {};

var $$WeakMap = {};

var $$WeakSet = {};

function has(array, idx) {
  return array[idx];
}

function isArray(prim) {
  return Array.isArray(prim);
}

var $$Array = {
  has: has,
  isArray: isArray
};

function raiseAny(any) {
  throw any;
}

var Exn = {
  raiseAny: raiseAny,
  raiseError: raiseAny
};

function plus(int1, int2) {
  return int1 + int2;
}

var Int = {
  plus: plus
};

function has$1(dict, key) {
  return dict[key];
}

function deleteInPlace(dict, key) {
  Js_dict.unsafeDeleteKey(dict, key);
}

var Dict = {
  has: has$1,
  deleteInPlace: deleteInPlace
};

var Float = {};

function toString(bigint) {
  return bigint.toString() + "n";
}

var $$BigInt = {
  toString: toString
};

function make2(ctxVarName1, ctxVarValue1, ctxVarName2, ctxVarValue2, inlinedFunction) {
  return new Function(ctxVarName1, ctxVarName2, "return " + inlinedFunction)(ctxVarValue1, ctxVarValue2);
}

var $$Function$1 = {
  make2: make2
};

var $$Symbol = {};

function stringify(any) {
  if (any === (void 0)) {
    return "undefined";
  } else {
    return JSON.stringify(any);
  }
}

function fromString(string) {
  return JSON.stringify(string);
}

var Value = {
  stringify: stringify,
  fromString: fromString
};

function toRescript($$float) {
  return $$float.toString() + (
          $$float % 1 === 0 ? "." : ""
        );
}

var Float$1 = {
  toRescript: toRescript
};

var Inlined = {
  Value: Value,
  Float: Float$1
};

var Stdlib = {
  Type: Type,
  $$Promise: $$Promise,
  Re: Re,
  $$Object: $$Object,
  $$WeakMap: $$WeakMap,
  $$WeakSet: $$WeakSet,
  $$Array: $$Array,
  Exn: Exn,
  Int: Int,
  Dict: Dict,
  Float: Float,
  $$BigInt: $$BigInt,
  $$Function: $$Function$1,
  $$Symbol: $$Symbol,
  Inlined: Inlined
};

function toArray(path) {
  if (path === "") {
    return [];
  } else {
    return JSON.parse(path.split("\"][\"").join("\",\""));
  }
}

function fromInlinedLocation(inlinedLocation) {
  return "[" + inlinedLocation + "]";
}

function fromLocation($$location) {
  return "[" + JSON.stringify($$location) + "]";
}

function fromArray(array) {
  var len = array.length;
  if (len !== 1) {
    if (len !== 0) {
      return "[" + array.map(fromString).join("][") + "]";
    } else {
      return "";
    }
  }
  var $$location = array[0];
  return "[" + JSON.stringify($$location) + "]";
}

function concat(path, concatedPath) {
  return path + concatedPath;
}

var Path = {
  toArray: toArray,
  fromInlinedLocation: fromInlinedLocation,
  fromLocation: fromLocation,
  fromArray: fromArray,
  concat: concat
};

var symbol = Symbol("rescript-schema");

var itemSymbol = Symbol("item");

var Raised = /* @__PURE__ */Caml_exceptions.create("S_Core-RescriptSchema.Raised");

function unsafeGetVariantPayload(variant) {
  return variant._0;
}

function unsafeGetErrorPayload(variant) {
  return variant._1;
}

class RescriptSchemaError extends Error {
      constructor(code, operation, path) {
        super();
        this.operation = operation;
        this.code = code;
        this.path = path;
        this.s = symbol;
        this.RE_EXN_ID = Raised;
        this._1 = this;
        this.Error = this;
        this.name = "RescriptSchemaError";
      }
      get message() {
        return message(this);
      }
      get reason() {
        return reason(this);
      }
    }
;

function getOrRethrow(exn) {
  if ((exn&&exn.s===symbol)) {
    return exn;
  }
  throw (exn&&exn.RE_EXN_ID==='JsError') ? exn._1 : exn;
}

function raise(code, operation, path) {
  throw new RescriptSchemaError(code, operation, path);
}

function prependLocationOrRethrow(exn, $$location) {
  var error = getOrRethrow(exn);
  var path = "[" + JSON.stringify($$location) + "]" + error.path;
  throw new RescriptSchemaError(error.code, error.operation, path);
}

function panic(message) {
  throw new Error("[rescript-schema] " + message);
}

var InternalError = {
  getOrRethrow: getOrRethrow,
  raise: raise,
  prependLocationOrRethrow: prependLocationOrRethrow,
  panic: panic
};

function make(selfSchema, path, operation) {
  return {
          schema: selfSchema,
          fail: (function (message, customPathOpt) {
              var customPath = customPathOpt !== undefined ? customPathOpt : "";
              throw new RescriptSchemaError({
                        TAG: "OperationFailed",
                        _0: message
                      }, operation, path + customPath);
            })
        };
}

var EffectCtx = {
  make: make
};

function classify(schema) {
  return schema.r;
}

function make$1(prim) {
  return prim;
}

function embed(b, value) {
  return "e[" + (b.g.e.push(value) - 1) + "]";
}

function scope(b) {
  return {
          c: "",
          l: "",
          a: false,
          g: b.g
        };
}

function allocateScope(b) {
  var varsAllocation = b.l;
  b.a = true;
  if (varsAllocation === "") {
    return b.c;
  } else {
    return "let " + varsAllocation + ";" + b.c;
  }
}

function varWithoutAllocation(b) {
  var newCounter = b.g.v + 1;
  b.g.v = newCounter;
  return "v" + newCounter;
}

function allocateVal(b) {
  return {
          s: b,
          a: false
        };
}

function val(b, initial) {
  return {
          i: initial,
          s: b,
          a: false
        };
}

function asyncVal(b, initial) {
  return {
          i: initial,
          s: b,
          a: true
        };
}

function inline(_b, val) {
  var $$var = val.v;
  if ($$var !== undefined) {
    return $$var;
  } else {
    return val.i;
  }
}

function $$var(b, val) {
  var _var = val.v;
  if (_var !== undefined) {
    return _var;
  }
  var $$var$1 = varWithoutAllocation(b);
  var isValScopeActive = !val.s.a;
  var activeScope = isValScopeActive ? val.s : b;
  var i = val.i;
  var allocation = i !== undefined && isValScopeActive ? $$var$1 + "=" + i : $$var$1;
  var varsAllocation = activeScope.l;
  activeScope.l = varsAllocation === "" ? allocation : varsAllocation + "," + allocation;
  var i$1 = val.i;
  if (i$1 !== undefined && !isValScopeActive) {
    b.c = b.c + ($$var$1 + "=" + i$1 + ";");
  }
  val.v = $$var$1;
  return $$var$1;
}

function push(b, input, val) {
  return $$var(b, input) + ".push(" + inline(b, val) + ")";
}

function addKey(b, input, key, val) {
  return $$var(b, input) + "[" + key + "]=" + inline(b, val);
}

function set(b, input, val) {
  if (input === val) {
    return "";
  }
  var match = input.a;
  if (match) {
    var match$1 = val.a;
    if (!match$1) {
      return $$var(b, input) + "=()=>Promise.resolve(" + inline(b, val) + ")";
    }
    
  } else {
    var match$2 = val.a;
    if (match$2) {
      input.a = true;
      return $$var(b, input) + "=" + inline(b, val);
    }
    
  }
  return $$var(b, input) + "=" + inline(b, val);
}

function setInlined(b, input, inlined) {
  return $$var(b, input) + "=" + inlined;
}

function map(b, inlinedFn, input) {
  return val(b, inlinedFn + "(" + inline(b, input) + ")");
}

var Val = {
  inline: inline,
  $$var: $$var,
  push: push,
  addKey: addKey,
  set: set,
  setInlined: setInlined,
  map: map
};

function isInternalError(_b, $$var) {
  return $$var + "&&" + $$var + ".s===s";
}

function transform(b, input, operation) {
  if (!input.a) {
    return operation(b, input);
  }
  var bb = scope(b);
  var operationInput = {
    v: varWithoutAllocation(bb),
    s: bb,
    a: false
  };
  var operationOutputVal = operation(bb, operationInput);
  var operationCode = allocateScope(bb);
  return asyncVal(b, "()=>" + $$var(b, input) + "().then(" + $$var(b, operationInput) + "=>{" + operationCode + "return " + (
              operationOutputVal.a ? "(" + inline(b, operationOutputVal) + ")()" : inline(b, operationOutputVal)
            ) + "})");
}

function embedSyncOperation(b, input, fn) {
  return transform(b, input, (function (b, input) {
                return map(b, "e[" + (b.g.e.push(fn) - 1) + "]", input);
              }));
}

function embedAsyncOperation(b, input, fn) {
  return transform(b, input, (function (b, input) {
                var val = map(b, "e[" + (b.g.e.push(fn) - 1) + "]", input);
                val.a = true;
                return val;
              }));
}

function raiseWithArg(b, path, fn, arg) {
  return "e[" + (b.g.e.push(function (arg) {
                var code = fn(arg);
                throw new RescriptSchemaError(code, b.g.o, path);
              }) - 1) + "](" + arg + ")";
}

function fail(b, message, path) {
  return "e[" + (b.g.e.push(function () {
                throw new RescriptSchemaError({
                          TAG: "OperationFailed",
                          _0: message
                        }, b.g.o, path);
              }) - 1) + "]()";
}

function invalidOperation(b, path, description) {
  throw new RescriptSchemaError({
            TAG: "InvalidOperation",
            description: description
          }, b.g.o, path);
}

function withCatch(b, input, $$catch, fn) {
  var prevCode = b.c;
  b.c = "";
  var errorVar = varWithoutAllocation(b);
  var maybeResolveVal = $$catch(b, errorVar);
  var catchCode = "if(" + (errorVar + "&&" + errorVar + ".s===s") + "){" + b.c;
  b.c = "";
  var bb = scope(b);
  var fnOutput = fn(bb);
  b.c = b.c + allocateScope(bb);
  var isAsync = fnOutput.a;
  var output = input === fnOutput ? input : ({
        s: b,
        a: isAsync
      });
  var catchCode$1 = maybeResolveVal !== undefined ? (function (catchLocation) {
        return catchCode + (
                catchLocation === 1 ? "return Promise.resolve(" + inline(b, maybeResolveVal) + ")" : (
                    catchLocation === 2 ? "return " + inline(b, maybeResolveVal) : set(b, output, maybeResolveVal)
                  )
              ) + ("}else{throw " + errorVar + "}");
      }) : (function (param) {
        return catchCode + "}throw " + errorVar;
      });
  var fnOutputVar = $$var(b, fnOutput);
  b.c = prevCode + ("try{" + b.c + (
      isAsync ? setInlined(b, output, "()=>{try{return " + fnOutputVar + "().catch(" + errorVar + "=>{" + catchCode$1(2) + "})}catch(" + errorVar + "){" + catchCode$1(1) + "}}") : set(b, output, fnOutput)
    ) + "}catch(" + errorVar + "){" + catchCode$1(0) + "}");
  return output;
}

function withPathPrepend(b, input, path, maybeDynamicLocationVar, fn) {
  if (path === "" && maybeDynamicLocationVar === undefined) {
    return fn(b, input, path);
  }
  try {
    return withCatch(b, input, (function (b, errorVar) {
                  b.c = errorVar + ".path=" + JSON.stringify(path) + "+" + (
                    maybeDynamicLocationVar !== undefined ? "'[\"'+" + maybeDynamicLocationVar + "+'\"]'+" : ""
                  ) + errorVar + ".path";
                }), (function (b) {
                  return fn(b, input, "");
                }));
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === Raised) {
      var error$1 = error._1;
      throw new RescriptSchemaError(error$1.code, error$1.operation, path + "[]" + error$1.path);
    }
    throw error;
  }
}

function typeFilterCode(b, typeFilter, schema, input, path) {
  var inputVar = $$var(b, input);
  return "if(" + typeFilter(inputVar) + "){" + raiseWithArg(b, path, (function (input) {
                return {
                        TAG: "InvalidType",
                        expected: schema,
                        received: input
                      };
              }), inputVar) + "}";
}

function serialize(b, schema, input, path) {
  return schema.s(b, input, schema, path);
}

function parse(b, schema, input, path) {
  return schema.p(b, input, schema, path);
}

function parseWithTypeCheck(b, schema, input, path) {
  var typeFilter = schema.f;
  if (typeFilter === undefined) {
    return schema.p(b, input, schema, path);
  }
  b.c = b.c + typeFilterCode(b, typeFilter, schema, input, path);
  var bb = scope(b);
  var val = schema.p(bb, input, schema, path);
  b.c = b.c + allocateScope(bb);
  return val;
}

var B = {
  embed: embed,
  scope: scope,
  allocateScope: allocateScope,
  varWithoutAllocation: varWithoutAllocation,
  allocateVal: allocateVal,
  val: val,
  asyncVal: asyncVal,
  Val: Val,
  isInternalError: isInternalError,
  transform: transform,
  embedSyncOperation: embedSyncOperation,
  embedAsyncOperation: embedAsyncOperation,
  raiseWithArg: raiseWithArg,
  fail: fail,
  invalidOperation: invalidOperation,
  withCatch: withCatch,
  withPathPrepend: withPathPrepend,
  typeFilterCode: typeFilterCode,
  serialize: serialize,
  parse: parse,
  parseWithTypeCheck: parseWithTypeCheck
};

function noop(_b, input, param, param$1) {
  return input;
}

function noopOperation(i) {
  return i;
}

function build(builder, schema, operation) {
  var b = {
    c: "",
    l: "",
    a: false,
    g: {
      v: -1,
      o: operation,
      e: []
    }
  };
  var input = {
    v: "i",
    s: b,
    a: false
  };
  var output = builder(b, input, schema, "");
  if (b.l !== "") {
    b.c = "let " + b.l + ";" + b.c;
  }
  if (operation === "Parsing") {
    var typeFilter = schema.f;
    if (typeFilter !== undefined) {
      b.c = typeFilterCode(b, typeFilter, schema, input, "") + b.c;
    }
    schema.i = output.a;
  }
  if (b.c === "" && output === input) {
    return noopOperation;
  }
  var inlinedFunction = "i=>{" + b.c + "return " + inline(b, output) + "}";
  return new Function("e", "s", "return " + inlinedFunction)(b.g.e, symbol);
}

var Builder = {
  make: make$1,
  B: B,
  noop: noop,
  noopOperation: noopOperation,
  build: build
};

function value(literal) {
  return literal.value;
}

function isJsonable(literal) {
  return literal.j;
}

function toString$1(literal) {
  return literal.s;
}

function arrayCheckBuilder(b, inputVar, literal) {
  var items = literal.i;
  return "(" + inputVar + "===" + ("e[" + (b.g.e.push(literal.value) - 1) + "]") + "||Array.isArray(" + inputVar + ")&&" + inputVar + ".length===" + items.length + (
          items.length > 0 ? "&&" + items.map(function (literal, idx) {
                    return literal.b(b, inputVar + "[" + idx + "]", literal);
                  }).join("&&") : ""
        ) + ")";
}

function dictCheckBuilder(b, inputVar, literal) {
  var items = literal.i;
  var fields = Object.keys(items);
  var numberOfFields = fields.length;
  return "(" + inputVar + "===" + ("e[" + (b.g.e.push(value) - 1) + "]") + "||" + inputVar + "&&" + inputVar + ".constructor===Object&&Object.keys(" + inputVar + ").length===" + numberOfFields + (
          numberOfFields > 0 ? "&&" + fields.map(function (field) {
                    var literal = items[field];
                    return literal.b(b, inputVar + "[" + JSON.stringify(field) + "]", literal);
                  }).join("&&") : ""
        ) + ")";
}

function inlinedStrictEqualCheckBuilder(param, inputVar, literal) {
  return inputVar + "===" + literal.s;
}

function strictEqualCheckBuilder(b, inputVar, literal) {
  return inputVar + "===" + ("e[" + (b.g.e.push(literal.value) - 1) + "]");
}

var undefined_value = undefined;

var $$undefined = {
  kind: "Undefined",
  value: undefined_value,
  s: "undefined",
  b: inlinedStrictEqualCheckBuilder,
  j: false
};

var null_value = null;

var $$null = {
  kind: "Null",
  value: null_value,
  s: "null",
  b: inlinedStrictEqualCheckBuilder,
  j: true
};

var nan_value = NaN;

function nan_b(param, inputVar, param$1) {
  return "Number.isNaN(" + inputVar + ")";
}

var nan = {
  kind: "NaN",
  value: nan_value,
  s: "NaN",
  b: nan_b,
  j: false
};

function string(value) {
  return {
          kind: "String",
          value: value,
          s: JSON.stringify(value),
          b: inlinedStrictEqualCheckBuilder,
          j: true
        };
}

function $$boolean(value) {
  return {
          kind: "Boolean",
          value: value,
          s: value ? "true" : "false",
          b: inlinedStrictEqualCheckBuilder,
          j: true
        };
}

function number(value) {
  return {
          kind: "Number",
          value: value,
          s: value.toString(),
          b: inlinedStrictEqualCheckBuilder,
          j: true
        };
}

function symbol$1(value) {
  return {
          kind: "Symbol",
          value: value,
          s: value.toString(),
          b: strictEqualCheckBuilder,
          j: false
        };
}

function bigint(value) {
  return {
          kind: "BigInt",
          value: value,
          s: value.toString() + "n",
          b: inlinedStrictEqualCheckBuilder,
          j: false
        };
}

function $$function(value) {
  return {
          kind: "Function",
          value: value,
          s: value.toString(),
          b: strictEqualCheckBuilder,
          j: false
        };
}

function object(value) {
  return {
          kind: "Object",
          value: value,
          s: Object.prototype.toString.call(value),
          b: strictEqualCheckBuilder,
          j: false
        };
}

function parseInternal(value) {
  var typeOfValue = typeof value;
  if (typeOfValue === "symbol") {
    return symbol$1(value);
  } else if (typeOfValue === "boolean") {
    return $$boolean(value);
  } else if (typeOfValue === "string") {
    return string(value);
  } else if (typeOfValue === "function") {
    return $$function(value);
  } else if (typeOfValue === "object") {
    if (value === null) {
      return $$null;
    } else if (Array.isArray(value)) {
      return array(value);
    } else if (value.constructor === Object) {
      return dict(value);
    } else {
      return object(value);
    }
  } else if (typeOfValue === "undefined") {
    return $$undefined;
  } else if (typeOfValue === "number") {
    if (Number.isNaN(value)) {
      return nan;
    } else {
      return number(value);
    }
  } else {
    return bigint(value);
  }
}

function dict(value) {
  var items = {};
  var string = "{";
  var isJsonable = true;
  var fields = Object.keys(value);
  var numberOfFields = fields.length;
  for(var idx = 0; idx < numberOfFields; ++idx){
    var field = fields[idx];
    var itemValue = value[field];
    var itemLiteral = parseInternal(itemValue);
    if (isJsonable && !itemLiteral.j) {
      isJsonable = false;
    }
    if (idx !== 0) {
      string = string + ",";
    }
    string = string + (JSON.stringify(field) + ":" + itemLiteral.s);
    items[field] = itemLiteral;
  }
  return {
          kind: "Dict",
          value: value,
          s: string + "}",
          b: dictCheckBuilder,
          j: isJsonable,
          i: Caml_option.some(items)
        };
}

function array(value) {
  var items = [];
  var isJsonable = true;
  var string = "[";
  for(var idx = 0 ,idx_finish = value.length; idx < idx_finish; ++idx){
    var itemValue = value[idx];
    var itemLiteral = parseInternal(itemValue);
    if (isJsonable && !itemLiteral.j) {
      isJsonable = false;
    }
    if (idx !== 0) {
      string = string + ",";
    }
    string = string + itemLiteral.s;
    items.push(itemLiteral);
  }
  return {
          kind: "Array",
          value: value,
          s: string + "]",
          b: arrayCheckBuilder,
          j: isJsonable,
          i: Caml_option.some(items)
        };
}

function parse$1(any) {
  return parseInternal(any);
}

function isLiteralSchema(schema) {
  return schema.r.TAG === "Literal";
}

function unsafeFromSchema(schema) {
  return schema.r._0;
}

var Literal = {
  value: value,
  isJsonable: isJsonable,
  toString: toString$1,
  arrayCheckBuilder: arrayCheckBuilder,
  dictCheckBuilder: dictCheckBuilder,
  inlinedStrictEqualCheckBuilder: inlinedStrictEqualCheckBuilder,
  strictEqualCheckBuilder: strictEqualCheckBuilder,
  $$undefined: $$undefined,
  $$null: $$null,
  nan: nan,
  string: string,
  $$boolean: $$boolean,
  number: number,
  symbol: symbol$1,
  bigint: bigint,
  $$function: $$function,
  object: object,
  parseInternal: parseInternal,
  dict: dict,
  array: array,
  parse: parse$1,
  isLiteralSchema: isLiteralSchema,
  unsafeFromSchema: unsafeFromSchema
};

function isAsyncParse(schema) {
  var v = schema.i;
  if (typeof v === "boolean") {
    return v;
  }
  try {
    build(schema.p, schema, "Parsing");
    return schema.i;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    getOrRethrow(exn);
    return false;
  }
}

function validateJsonableSchema(_schema, rootSchema, _isRootOpt) {
  while(true) {
    var isRootOpt = _isRootOpt;
    var schema = _schema;
    var isRoot = isRootOpt !== undefined ? isRootOpt : false;
    if (!(isRoot || rootSchema !== schema)) {
      return ;
    }
    var childrenSchemas = schema.r;
    var exit = 0;
    if (typeof childrenSchemas !== "object") {
      if (childrenSchemas !== "Unknown") {
        return ;
      }
      exit = 2;
    } else {
      switch (childrenSchemas.TAG) {
        case "Literal" :
            if (childrenSchemas._0.j) {
              return ;
            }
            exit = 2;
            break;
        case "Option" :
            exit = 2;
            break;
        case "Object" :
            var items = childrenSchemas.items;
            for(var idx = 0 ,idx_finish = items.length; idx < idx_finish; ++idx){
              var item = items[idx];
              try {
                var s = item.t.r;
                var tmp;
                tmp = typeof s !== "object" || s.TAG !== "Option" ? item.t : s._0;
                validateJsonableSchema(tmp, rootSchema, undefined);
              }
              catch (raw_exn){
                var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                prependLocationOrRethrow(exn, item.l);
              }
            }
            return ;
        case "Tuple" :
            childrenSchemas.items.forEach(function (item, idx) {
                  try {
                    return validateJsonableSchema(item.t, rootSchema, undefined);
                  }
                  catch (raw_exn){
                    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    return prependLocationOrRethrow(exn, idx.toString());
                  }
                });
            return ;
        case "Union" :
            childrenSchemas._0.forEach(function (schema) {
                  validateJsonableSchema(schema, rootSchema, undefined);
                });
            return ;
        case "Null" :
        case "Array" :
        case "Dict" :
            exit = 1;
            break;
        default:
          return ;
      }
    }
    switch (exit) {
      case 1 :
          _isRootOpt = undefined;
          _schema = childrenSchemas._0;
          continue ;
      case 2 :
          throw new RescriptSchemaError({
                    TAG: "InvalidJsonStruct",
                    _0: schema
                  }, "Serializing", "");
      
    }
  };
}

function make$2(name, rawTagged, metadataMap, parseOperationBuilder, serializeOperationBuilder, maybeTypeFilter) {
  return {
          r: rawTagged,
          n: name,
          p: parseOperationBuilder,
          s: serializeOperationBuilder,
          f: maybeTypeFilter,
          i: 0,
          m: metadataMap
        };
}

function makeWithNoopSerializer(name, rawTagged, metadataMap, parseOperationBuilder, maybeTypeFilter) {
  return {
          r: rawTagged,
          n: name,
          p: parseOperationBuilder,
          s: noop,
          f: maybeTypeFilter,
          i: 0,
          m: metadataMap
        };
}

function unexpectedAsync() {
  throw new RescriptSchemaError("UnexpectedAsync", "Parsing", "");
}

function make$3(label, init) {
  return function (i, s) {
    try {
      return s[label](i);
    }
    catch (exn){
      if (s[label]) {
        throw exn;
      }
      var o = init(s);
      s[label] = o;
      return o(i);
    }
  };
}

var Operation = {
  unexpectedAsync: unexpectedAsync,
  make: make$3
};

function init(schema) {
  var operation = build(schema.p, schema, "Parsing");
  var isAsync = schema.i;
  if (isAsync) {
    return unexpectedAsync;
  } else {
    return operation;
  }
}

function parseAnyOrRaiseWith(i, s) {
  try {
    return s["op"](i);
  }
  catch (exn){
    if (s["op"]) {
      throw exn;
    }
    var o = init(s);
    s["op"] = o;
    return o(i);
  }
}

function parseAnyWith(any, schema) {
  try {
    return {
            TAG: "Ok",
            _0: parseAnyOrRaiseWith(any, schema)
          };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    return {
            TAG: "Error",
            _0: getOrRethrow(exn)
          };
  }
}

function asyncPrepareOk(value) {
  return {
          TAG: "Ok",
          _0: value
        };
}

function asyncPrepareError(jsExn) {
  return {
          TAG: "Error",
          _0: getOrRethrow(jsExn)
        };
}

function init$1(schema) {
  var operation = build(schema.p, schema, "Parsing");
  var isAsync = schema.i;
  if (isAsync) {
    return operation;
  } else {
    return function (input) {
      var syncValue = operation(input);
      return function () {
        return Promise.resolve(syncValue);
      };
    };
  }
}

function internalParseAsyncWith(i, s) {
  try {
    return s["opa"](i);
  }
  catch (exn){
    if (s["opa"]) {
      throw exn;
    }
    var o = init$1(s);
    s["opa"] = o;
    return o(i);
  }
}

function parseAnyAsyncWith(any, schema) {
  try {
    return internalParseAsyncWith(any, schema)().then(asyncPrepareOk, asyncPrepareError);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    return Promise.resolve({
                TAG: "Error",
                _0: getOrRethrow(exn)
              });
  }
}

function parseAnyAsyncInStepsWith(any, schema) {
  try {
    var asyncFn = internalParseAsyncWith(any, schema);
    return {
            TAG: "Ok",
            _0: (function () {
                return asyncFn().then(asyncPrepareOk, asyncPrepareError);
              })
          };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    return {
            TAG: "Error",
            _0: getOrRethrow(exn)
          };
  }
}

function init$2(schema) {
  validateJsonableSchema(schema, schema, true);
  return build(schema.s, schema, "Serializing");
}

function serializeOrRaiseWith(i, s) {
  try {
    return s["osj"](i);
  }
  catch (exn){
    if (s["osj"]) {
      throw exn;
    }
    var o = init$2(s);
    s["osj"] = o;
    return o(i);
  }
}

function serializeWith(value, schema) {
  try {
    return {
            TAG: "Ok",
            _0: serializeOrRaiseWith(value, schema)
          };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    return {
            TAG: "Error",
            _0: getOrRethrow(exn)
          };
  }
}

function init$3(schema) {
  return build(schema.s, schema, "Serializing");
}

function serializeToUnknownOrRaiseWith(i, s) {
  try {
    return s["os"](i);
  }
  catch (exn){
    if (s["os"]) {
      throw exn;
    }
    var o = init$3(s);
    s["os"] = o;
    return o(i);
  }
}

function serializeToUnknownWith(value, schema) {
  try {
    return {
            TAG: "Ok",
            _0: serializeToUnknownOrRaiseWith(value, schema)
          };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    return {
            TAG: "Error",
            _0: getOrRethrow(exn)
          };
  }
}

function serializeToJsonStringWith(value, schema, spaceOpt) {
  var space = spaceOpt !== undefined ? spaceOpt : 0;
  var json = serializeWith(value, schema);
  if (json.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: JSON.stringify(json._0, null, space)
          };
  } else {
    return json;
  }
}

function serializeToJsonStringOrRaiseWith(value, schema, spaceOpt) {
  var space = spaceOpt !== undefined ? spaceOpt : 0;
  return JSON.stringify(serializeOrRaiseWith(value, schema), null, space);
}

function parseJsonStringWith(json, schema) {
  var json$1;
  try {
    json$1 = {
      TAG: "Ok",
      _0: JSON.parse(json)
    };
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === Js_exn.$$Error) {
      json$1 = {
        TAG: "Error",
        _0: new RescriptSchemaError({
              TAG: "OperationFailed",
              _0: error._1.message
            }, "Parsing", "")
      };
    } else {
      throw error;
    }
  }
  if (json$1.TAG === "Ok") {
    return parseAnyWith(json$1._0, schema);
  } else {
    return json$1;
  }
}

function make$4(namespace, name) {
  return namespace + ":" + name;
}

var Id = {
  make: make$4
};

var empty = {};

function set$1(map, id, metadata) {
  if (map === empty) {
    return ({[id]:metadata});
  }
  var copy = Object.assign({}, map);
  copy[id] = metadata;
  return copy;
}

var $$Map = {
  empty: empty,
  set: set$1
};

function get(schema, id) {
  return schema.m[id];
}

function set$2(schema, id, metadata) {
  var metadataMap = set$1(schema.m, id, metadata);
  return {
          r: schema.r,
          n: schema.n,
          p: schema.p,
          s: schema.s,
          f: schema.f,
          i: 0,
          m: metadataMap
        };
}

var Metadata = {
  Id: Id,
  $$Map: $$Map,
  get: get,
  set: set$2
};

function recursive(fn) {
  var placeholder = {
    m: empty
  };
  var schema = fn(placeholder);
  Object.assign(placeholder, schema);
  placeholder.d = undefined;
  var builder = placeholder.p;
  placeholder.p = (function (b, input, selfSchema, path) {
      selfSchema.p = noop;
      var init = b.g;
      var b$1 = {
        c: "",
        l: "",
        a: false,
        g: {
          v: -1,
          o: init.o,
          e: []
        }
      };
      var input$1 = {
        v: "i",
        s: b$1,
        a: false
      };
      var output = builder(b$1, input$1, selfSchema, path);
      var isAsync = output.a;
      selfSchema.p = (function (b, input, selfSchema, param) {
          if (isAsync) {
            return embedAsyncOperation(b, input, (function (input) {
                          return internalParseAsyncWith(input, selfSchema);
                        }));
          } else {
            return embedSyncOperation(b, input, (function (input) {
                          return parseAnyOrRaiseWith(input, selfSchema);
                        }));
          }
        });
      var operation = build(builder, selfSchema, "Parsing");
      if (isAsync) {
        selfSchema["opa"] = operation;
      } else {
        selfSchema["op"] = operation;
      }
      selfSchema.p = builder;
      return withPathPrepend(b, input, path, undefined, (function (b, input, param) {
                    if (isAsync) {
                      return embedAsyncOperation(b, input, operation);
                    } else {
                      return embedSyncOperation(b, input, operation);
                    }
                  }));
    });
  var builder$1 = placeholder.s;
  placeholder.s = (function (b, input, selfSchema, path) {
      selfSchema.s = (function (b, input, selfSchema, param) {
          return embedSyncOperation(b, input, (function (input) {
                        return serializeToUnknownOrRaiseWith(input, selfSchema);
                      }));
        });
      var operation = build(builder$1, selfSchema, "Serializing");
      selfSchema["os"] = operation;
      selfSchema.s = builder$1;
      return withPathPrepend(b, input, path, undefined, (function (b, input, param) {
                    return embedSyncOperation(b, input, operation);
                  }));
    });
  return placeholder;
}

function setName(schema, name) {
  return {
          r: schema.r,
          n: (function () {
              return name;
            }),
          p: schema.p,
          s: schema.s,
          f: schema.f,
          i: 0,
          m: schema.m
        };
}

function primitiveName() {
  return this.r;
}

function containerName() {
  var tagged = this.r;
  return tagged.TAG + "(" + tagged._0.n() + ")";
}

function internalRefine(schema, refiner) {
  return {
          r: schema.r,
          n: schema.n,
          p: (function (b, input, selfSchema, path) {
              return transform(b, schema.p(b, input, schema, path), (function (b, input) {
                            var rCode = refiner(b, input, selfSchema, path);
                            b.c = b.c + rCode;
                            return input;
                          }));
            }),
          s: (function (b, input, selfSchema, path) {
              var input$1 = transform(b, input, (function (b, input) {
                      b.c = b.c + refiner(b, input, selfSchema, path);
                      return input;
                    }));
              return schema.s(b, input$1, schema, path);
            }),
          f: schema.f,
          i: 0,
          m: schema.m
        };
}

function refine(schema, refiner) {
  return internalRefine(schema, (function (b, input, selfSchema, path) {
                var value = refiner(make(selfSchema, path, b.g.o));
                return "e[" + (b.g.e.push(value) - 1) + "](" + $$var(b, input) + ");";
              }));
}

function addRefinement(schema, metadataId, refinement, refiner) {
  var refinements = schema.m[metadataId];
  return internalRefine(set$2(schema, metadataId, refinements !== undefined ? refinements.concat(refinement) : [refinement]), refiner);
}

function transform$1(schema, transformer) {
  return {
          r: schema.r,
          n: schema.n,
          p: (function (b, input, selfSchema, path) {
              var input$1 = schema.p(b, input, schema, path);
              var match = transformer(make(selfSchema, path, b.g.o));
              var parser = match.p;
              if (parser !== undefined) {
                if (match.a !== undefined) {
                  return invalidOperation(b, path, "The S.transform doesn't allow parser and asyncParser at the same time. Remove parser in favor of asyncParser");
                } else {
                  return embedSyncOperation(b, input$1, parser);
                }
              }
              var asyncParser = match.a;
              if (asyncParser !== undefined) {
                return embedAsyncOperation(b, input$1, asyncParser);
              } else if (match.s !== undefined) {
                return invalidOperation(b, path, "The S.transform parser is missing");
              } else {
                return input$1;
              }
            }),
          s: (function (b, input, selfSchema, path) {
              var match = transformer(make(selfSchema, path, b.g.o));
              var serializer = match.s;
              if (serializer === undefined) {
                if (match.a !== undefined || match.p !== undefined) {
                  return invalidOperation(b, path, "The S.transform serializer is missing");
                } else {
                  return schema.s(b, input, schema, path);
                }
              }
              var input$1 = embedSyncOperation(b, input, serializer);
              return schema.s(b, input$1, schema, path);
            }),
          f: schema.f,
          i: 0,
          m: schema.m
        };
}

function preprocess(schema, transformer) {
  var unionSchemas = schema.r;
  if (typeof unionSchemas === "object" && unionSchemas.TAG === "Union") {
    return {
            r: {
              TAG: "Union",
              _0: unionSchemas._0.map(function (unionSchema) {
                    return preprocess(unionSchema, transformer);
                  })
            },
            n: schema.n,
            p: schema.p,
            s: schema.s,
            f: schema.f,
            i: 0,
            m: schema.m
          };
  }
  return {
          r: schema.r,
          n: schema.n,
          p: (function (b, input, selfSchema, path) {
              var match = transformer(make(selfSchema, path, b.g.o));
              var parser = match.p;
              if (parser !== undefined) {
                if (match.a !== undefined) {
                  return invalidOperation(b, path, "The S.preprocess doesn't allow parser and asyncParser at the same time. Remove parser in favor of asyncParser");
                } else {
                  return parseWithTypeCheck(b, schema, embedSyncOperation(b, input, parser), path);
                }
              }
              var asyncParser = match.a;
              if (asyncParser !== undefined) {
                return transform(b, embedAsyncOperation(b, input, asyncParser), (function (b, input) {
                              return parseWithTypeCheck(b, schema, input, path);
                            }));
              } else {
                return parseWithTypeCheck(b, schema, input, path);
              }
            }),
          s: (function (b, input, selfSchema, path) {
              var input$1 = schema.s(b, input, schema, path);
              var match = transformer(make(selfSchema, path, b.g.o));
              var serializer = match.s;
              if (serializer !== undefined) {
                return embedSyncOperation(b, input$1, serializer);
              } else {
                return input$1;
              }
            }),
          i: 0,
          m: schema.m
        };
}

function custom(name, definer) {
  return {
          r: "Unknown",
          n: (function () {
              return name;
            }),
          p: (function (b, input, selfSchema, path) {
              var match = definer(make(selfSchema, path, b.g.o));
              var parser = match.p;
              if (parser !== undefined) {
                if (match.a !== undefined) {
                  return invalidOperation(b, path, "The S.custom doesn't allow parser and asyncParser at the same time. Remove parser in favor of asyncParser");
                } else {
                  return embedSyncOperation(b, input, parser);
                }
              }
              var asyncParser = match.a;
              if (asyncParser !== undefined) {
                return embedAsyncOperation(b, input, asyncParser);
              } else if (match.s !== undefined) {
                return invalidOperation(b, path, "The S.custom parser is missing");
              } else {
                return input;
              }
            }),
          s: (function (b, input, selfSchema, path) {
              var match = definer(make(selfSchema, path, b.g.o));
              var serializer = match.s;
              if (serializer !== undefined) {
                return embedSyncOperation(b, input, serializer);
              } else if (match.a !== undefined || match.p !== undefined) {
                return invalidOperation(b, path, "The S.custom serializer is missing");
              } else {
                return input;
              }
            }),
          i: 0,
          m: empty
        };
}

function literal(value) {
  var literal$1 = parseInternal(value);
  var operationBuilder = function (b, input, param, path) {
    var inputVar = $$var(b, input);
    b.c = b.c + (literal$1.b(b, inputVar, literal$1) + "||" + raiseWithArg(b, path, (function (input) {
              return {
                      TAG: "InvalidLiteral",
                      expected: literal$1,
                      received: input
                    };
            }), inputVar) + ";");
    return input;
  };
  return {
          r: {
            TAG: "Literal",
            _0: literal$1
          },
          n: (function () {
              return "Literal(" + literal$1.s + ")";
            }),
          p: operationBuilder,
          s: operationBuilder,
          i: 0,
          m: empty
        };
}

var unit = literal((void 0));

function isEmbeded(definition, embeded) {
  return embeded === definition;
}

function isEmbededBySet(definition, embededSet) {
  return embededSet.has(definition);
}

function isNode(definition) {
  if (typeof definition === "object") {
    return definition !== null;
  } else {
    return false;
  }
}

function toConstant(prim) {
  return prim;
}

function toEmbeded(prim) {
  return prim;
}

function toNode(prim) {
  return prim;
}

function isEmbededItem(definition) {
  return definition.s === itemSymbol;
}

var Definition = {
  isEmbeded: isEmbeded,
  isEmbededBySet: isEmbededBySet,
  isNode: isNode,
  toConstant: toConstant,
  toEmbeded: toEmbeded,
  toNode: toNode,
  isEmbededItem: isEmbededItem
};

function factory(schema, definer) {
  return {
          r: schema.r,
          n: schema.n,
          p: (function (b, input, param, path) {
              return embedSyncOperation(b, schema.p(b, input, schema, path), definer);
            }),
          s: (function (b, input, selfSchema, path) {
              var inputVar = $$var(b, input);
              var definition = definer(symbol);
              var definitionToValue = function (definition, valuePath) {
                if (symbol === definition) {
                  return valuePath === "" ? input : val(b, inputVar + valuePath);
                }
                if (typeof definition === "object" && definition !== null) {
                  var keys = Object.keys(definition);
                  var maybeOutputRef = 0;
                  for(var idx = 0 ,idx_finish = keys.length; idx < idx_finish; ++idx){
                    var key = keys[idx];
                    var definition$1 = definition[key];
                    var maybeOutput = definitionToValue(definition$1, valuePath + ("[" + JSON.stringify(key) + "]"));
                    var match = maybeOutputRef;
                    if (typeof match !== "object") {
                      if (match === 0) {
                        maybeOutputRef = maybeOutput;
                      }
                      
                    } else if (!(typeof maybeOutput !== "object" && maybeOutput === 0)) {
                      maybeOutputRef = 1;
                    }
                    
                  }
                  return maybeOutputRef;
                }
                var constantVal = valuePath === "" ? input : val(b, inputVar + valuePath);
                var constantVar = $$var(b, constantVal);
                b.c = b.c + ("if(" + constantVar + "!==" + ("e[" + (b.g.e.push(definition) - 1) + "]") + "){" + raiseWithArg(b, path + valuePath, (function (input) {
                          return {
                                  TAG: "InvalidLiteral",
                                  expected: parseInternal(definition),
                                  received: input
                                };
                        }), constantVar) + "}");
                return 0;
              };
              var output = definitionToValue(definition, "");
              if (typeof output === "object") {
                return schema.s(b, output, schema, path);
              }
              if (output !== 0) {
                return invalidOperation(b, path, "The S.variant's value is registered multiple times");
              }
              if (selfSchema.r.TAG !== "Literal") {
                return invalidOperation(b, path, "The S.variant's value is not registered");
              }
              var value = selfSchema.r._0.value;
              var input$1 = val(b, "e[" + (b.g.e.push(value) - 1) + "]");
              return schema.s(b, input$1, schema, path);
            }),
          f: schema.f,
          i: 0,
          m: schema.m
        };
}

var Variant = {
  factory: factory
};

var defaultMetadataId = "rescript-schema:Option.default";

function $$default(schema) {
  return schema.m[defaultMetadataId];
}

function parseOperationBuilder(b, input, selfSchema, path) {
  var isNull = (selfSchema.r.TAG === "Null");
  var childSchema = selfSchema.r._0;
  var bb = scope(b);
  var itemOutput = childSchema.p(bb, input, childSchema, path);
  var itemCode = allocateScope(bb);
  var isTransformed = isNull || itemOutput !== input;
  var output = isTransformed ? ({
        s: b,
        a: itemOutput.a
      }) : input;
  if (itemCode !== "" || isTransformed) {
    b.c = b.c + ("if(" + $$var(b, input) + "!==" + (
        isNull ? "null" : "void 0"
      ) + "){" + itemCode + set(b, output, itemOutput) + "}" + (
        isNull || output.a ? "else{" + set(b, output, val(b, "void 0")) + "}" : ""
      ));
  }
  return output;
}

function serializeOperationBuilder(b, input, selfSchema, path) {
  var output = allocateVal(b);
  var inputVar = $$var(b, input);
  var isNull = (selfSchema.r.TAG === "Null");
  var childSchema = selfSchema.r._0;
  var bb = scope(b);
  var value = Caml_option.valFromOption;
  var input$1 = map(bb, "e[" + (bb.g.e.push(value) - 1) + "]", input);
  var itemOutput = childSchema.s(bb, input$1, childSchema, path);
  var itemCode = allocateScope(bb);
  b.c = b.c + ("if(" + inputVar + "!==void 0){" + itemCode + set(b, output, itemOutput) + "}" + (
      isNull ? "else{" + setInlined(b, output, "null") + "}" : ""
    ));
  return output;
}

function maybeTypeFilter(schema, inlinedNoneValue) {
  var typeFilter = schema.f;
  if (typeFilter !== undefined) {
    return (function (inputVar) {
              return inputVar + "!==" + inlinedNoneValue + "&&(" + typeFilter(inputVar) + ")";
            });
  }
  
}

function factory$1(schema) {
  return {
          r: {
            TAG: "Option",
            _0: schema
          },
          n: containerName,
          p: parseOperationBuilder,
          s: serializeOperationBuilder,
          f: maybeTypeFilter(schema, "void 0"),
          i: 0,
          m: empty
        };
}

function getWithDefault(schema, $$default) {
  return {
          r: schema.r,
          n: schema.n,
          p: (function (b, input, param, path) {
              return transform(b, schema.p(b, input, schema, path), (function (b, input) {
                            var inputVar = $$var(b, input);
                            var tmp;
                            tmp = $$default.TAG === "Value" ? "e[" + (b.g.e.push($$default._0) - 1) + "]" : "e[" + (b.g.e.push($$default._0) - 1) + "]()";
                            return val(b, inputVar + "===void 0?" + tmp + ":" + inputVar);
                          }));
            }),
          s: schema.s,
          f: schema.f,
          i: 0,
          m: set$1(schema.m, defaultMetadataId, $$default)
        };
}

function getOr(schema, defalutValue) {
  return getWithDefault(schema, {
              TAG: "Value",
              _0: defalutValue
            });
}

function getOrWith(schema, defalutCb) {
  return getWithDefault(schema, {
              TAG: "Callback",
              _0: defalutCb
            });
}

var $$Option = {
  defaultMetadataId: defaultMetadataId,
  $$default: $$default,
  parseOperationBuilder: parseOperationBuilder,
  serializeOperationBuilder: serializeOperationBuilder,
  maybeTypeFilter: maybeTypeFilter,
  factory: factory$1,
  getWithDefault: getWithDefault,
  getOr: getOr,
  getOrWith: getOrWith
};

function factory$2(schema) {
  return {
          r: {
            TAG: "Null",
            _0: schema
          },
          n: containerName,
          p: parseOperationBuilder,
          s: serializeOperationBuilder,
          f: maybeTypeFilter(schema, "null"),
          i: 0,
          m: empty
        };
}

var Null = {
  factory: factory$2
};

function nullable(schema) {
  return factory$1(factory$2(schema));
}

function builder(b, input, selfSchema, path) {
  b.c = b.c + raiseWithArg(b, path, (function (input) {
          return {
                  TAG: "InvalidType",
                  expected: selfSchema,
                  received: input
                };
        }), inline(b, input)) + ";";
  return input;
}

var schema = {
  r: "Never",
  n: primitiveName,
  p: builder,
  s: builder,
  i: 0,
  m: empty
};

var Never = {
  builder: builder,
  schema: schema
};

function typeFilter(inputVar) {
  return "!" + inputVar + "||" + inputVar + ".constructor!==Object";
}

function getItems(schema) {
  return schema.r.items;
}

function getDefinition(schema) {
  return schema.r.definition;
}

function parseOperationBuilder$1(b, input, selfSchema, path) {
  var asyncOutputVars = [];
  var outputs = new WeakMap();
  var parseItems = function (b, input, schema, path) {
    var inputVar = $$var(b, input);
    var items = schema.r.items;
    var isObject = schema.r.TAG === "Object";
    for(var idx = 0 ,idx_finish = items.length; idx < idx_finish; ++idx){
      var prevCode = b.c;
      b.c = "";
      var item = items[idx];
      var itemPath = item.p;
      var schema$1 = item.t;
      var itemInput = val(b, inputVar + itemPath);
      var path$1 = path + itemPath;
      var typeFilter = schema$1.f;
      if (typeFilter !== undefined) {
        b.c = b.c + typeFilterCode(b, typeFilter, schema$1, itemInput, path$1);
      }
      if (isObject && schema$1.d) {
        var bb = scope(b);
        parseItems(bb, itemInput, schema$1, path$1);
        b.c = prevCode + b.c + allocateScope(bb);
      } else {
        var itemOutput = schema$1.p(b, itemInput, schema$1, path$1);
        outputs.set(item, itemOutput);
        if (itemOutput.a) {
          asyncOutputVars.push($$var(b, itemOutput));
        }
        if (schema$1.r.TAG === "Literal") {
          b.c = b.c + prevCode;
        } else {
          b.c = prevCode + b.c;
        }
      }
    }
    if (!(isObject && selfSchema.r.unknownKeys === "Strict")) {
      return ;
    }
    var key = allocateVal(b);
    var keyVar = $$var(b, key);
    b.c = b.c + ("for(" + keyVar + " in " + inputVar + "){if(");
    if (items.length !== 0) {
      for(var idx$1 = 0 ,idx_finish$1 = items.length; idx$1 < idx_finish$1; ++idx$1){
        var item$1 = items[idx$1];
        if (idx$1 !== 0) {
          b.c = b.c + "&&";
        }
        b.c = b.c + (keyVar + "!==" + item$1.i);
      }
    } else {
      b.c = b.c + "true";
    }
    b.c = b.c + ("){" + raiseWithArg(b, path, (function (exccessFieldName) {
              return {
                      TAG: "ExcessField",
                      _0: exccessFieldName
                    };
            }), keyVar) + "}}");
  };
  parseItems(b, input, selfSchema, path);
  var definitionToValue = function (definition, outputPath) {
    var val = outputs.get(definition);
    if (val !== undefined) {
      return inline(b, val);
    }
    if (!(typeof definition === "object" && definition !== null)) {
      return "e[" + (b.g.e.push(definition) - 1) + "]";
    }
    var isArray = Array.isArray(definition);
    var keys = Object.keys(definition);
    var codeRef = isArray ? "[" : "{";
    for(var idx = 0 ,idx_finish = keys.length; idx < idx_finish; ++idx){
      var key = keys[idx];
      var definition$1 = definition[key];
      var output = definitionToValue(definition$1, outputPath + ("[" + JSON.stringify(key) + "]"));
      codeRef = codeRef + (
        isArray ? output : JSON.stringify(key) + ":" + output
      ) + ",";
    }
    return codeRef + (
            isArray ? "]" : "}"
          );
  };
  var syncOutput = definitionToValue(selfSchema.r.definition, "");
  if (asyncOutputVars.length === 0) {
    return val(b, syncOutput);
  } else {
    return asyncVal(b, "()=>Promise.all([" + asyncOutputVars.map(function (asyncOutputVar) {
                      return asyncOutputVar + "()";
                    }).join(",") + "]).then(([" + asyncOutputVars.toString() + "])=>(" + syncOutput + "))");
  }
}

function serializeOperationBuilder$1(b, input, selfSchema, path) {
  var inputVar = $$var(b, input);
  var ctx = {
    d: ""
  };
  var embededOutputs = new WeakMap();
  var definitionToOutput = function (definition, outputPath) {
    if (typeof definition === "object" && definition !== null) {
      if (definition.s === itemSymbol) {
        if (embededOutputs.has(definition)) {
          return invalidOperation(b, path, "The item " + definition.i + " is registered multiple times");
        }
        var schema = definition.t;
        var itemInput = val(b, inputVar + outputPath);
        var itemOutput = schema.s(b, itemInput, schema, path + outputPath);
        embededOutputs.set(definition, itemOutput);
        return ;
      }
      var keys = Object.keys(definition);
      for(var idx = 0 ,idx_finish = keys.length; idx < idx_finish; ++idx){
        var key = keys[idx];
        var definition$1 = definition[key];
        definitionToOutput(definition$1, outputPath + ("[" + JSON.stringify(key) + "]"));
      }
      return ;
    }
    var itemInputVar = inputVar + outputPath;
    ctx.d = ctx.d + ("if(" + itemInputVar + "!==" + ("e[" + (b.g.e.push(definition) - 1) + "]") + "){" + raiseWithArg(b, path + outputPath, (function (input) {
              return {
                      TAG: "InvalidLiteral",
                      expected: parseInternal(definition),
                      received: input
                    };
            }), itemInputVar) + "}");
  };
  definitionToOutput(selfSchema.r.definition, "");
  b.c = ctx.d + b.c;
  var toRaw = function (schema, path) {
    var items = schema.r.items;
    var isObject = schema.r.TAG === "Object";
    var output = "";
    for(var idx = 0 ,idx_finish = items.length; idx < idx_finish; ++idx){
      var item = items[idx];
      var o = embededOutputs.get(item);
      var itemOutput;
      if (o !== undefined) {
        itemOutput = inline(b, o);
      } else {
        var itemSchema = item.t;
        if (itemSchema.r.TAG === "Literal") {
          var value = itemSchema.r._0.value;
          itemOutput = "e[" + (b.g.e.push(value) - 1) + "]";
        } else {
          itemOutput = isObject && itemSchema.d ? toRaw(itemSchema, path + item.p) : invalidOperation(b, path, "The " + item.i + " item is not registered or not a literal");
        }
      }
      output = isObject ? output + (item.i + ":" + itemOutput + ",") : output + (itemOutput + ",");
    }
    if (isObject) {
      return "{" + output + "}";
    } else {
      return "[" + output + "]";
    }
  };
  return val(b, toRaw(selfSchema, path));
}

function name() {
  var schema = this;
  return "Object({" + schema.r.items.map(function (item) {
                return item.i + ": " + item.t.n();
              }).join(", ") + "})";
}

function factory$3(definer) {
  var fields = {};
  var items = [];
  var flatten = function (schema) {
    if (schema.d) {
      return schema.d(this);
    }
    var message = "The schema " + schema.n() + " can't be flattened";
    throw new Error("[rescript-schema] " + message);
  };
  var field = function (fieldName, schema) {
    var inlinedLocation = JSON.stringify(fieldName);
    var item = fields[fieldName];
    if (item !== undefined) {
      if (item.t.d && schema.d) {
        return schema.d(item.t.c);
      }
      throw new Error("[rescript-schema] " + ("The field " + inlinedLocation + " defined twice with incompatible schemas"));
    }
    var schema$1 = schema.d ? factory$3(schema.d) : schema;
    var item_p = "[" + inlinedLocation + "]";
    var item$1 = {
      t: schema$1,
      p: item_p,
      l: fieldName,
      i: inlinedLocation,
      s: itemSymbol
    };
    fields[fieldName] = item$1;
    items.push(item$1);
    if (schema$1.d) {
      return schema$1.r.definition;
    } else {
      return item$1;
    }
  };
  var tag = function (tag$1, asValue) {
    field(tag$1, literal(asValue));
  };
  var fieldOr = function (fieldName, schema, or) {
    return field(fieldName, getOr(factory$1(schema), or));
  };
  var nestedField = function (fieldName, nestedFieldName, schema) {
    var item = fields[fieldName];
    if (item === undefined) {
      return field(fieldName, factory$3(function (s) {
                      return s.f(nestedFieldName, schema);
                    }));
    }
    if (item.t.d) {
      return item.t.c.f(nestedFieldName, schema);
    }
    var message = "The field " + JSON.stringify(fieldName) + " defined twice with incompatible schemas";
    throw new Error("[rescript-schema] " + message);
  };
  var ctx = {
    field: field,
    f: field,
    fieldOr: fieldOr,
    tag: tag,
    nestedField: nestedField,
    flatten: flatten
  };
  var definition = definer(ctx);
  return {
          r: {
            TAG: "Object",
            items: items,
            fields: fields,
            unknownKeys: "Strip",
            definition: definition
          },
          n: name,
          p: parseOperationBuilder$1,
          s: serializeOperationBuilder$1,
          f: typeFilter,
          i: 0,
          d: definer,
          c: ctx,
          m: empty
        };
}

function setUnknownKeys(schema, unknownKeys) {
  var match = schema.r;
  if (typeof match !== "object" || !(match.TAG === "Object" && match.unknownKeys !== unknownKeys)) {
    return schema;
  } else {
    return {
            r: {
              TAG: "Object",
              items: match.items,
              fields: match.fields,
              unknownKeys: unknownKeys,
              definition: match.definition
            },
            n: schema.n,
            p: schema.p,
            s: schema.s,
            f: schema.f,
            i: schema.i,
            d: schema.d,
            c: schema.c,
            m: schema.m
          };
  }
}

function strip(schema) {
  return setUnknownKeys(schema, "Strip");
}

function strict(schema) {
  return setUnknownKeys(schema, "Strict");
}

var $$Object$1 = {
  typeFilter: typeFilter,
  getItems: getItems,
  getDefinition: getDefinition,
  parseOperationBuilder: parseOperationBuilder$1,
  serializeOperationBuilder: serializeOperationBuilder$1,
  name: name,
  factory: factory$3,
  setUnknownKeys: setUnknownKeys,
  strip: strip,
  strict: strict
};

var schema$1 = {
  r: "Unknown",
  n: primitiveName,
  p: noop,
  s: noop,
  i: false,
  m: empty
};

var Unknown = {
  schema: schema$1
};

var metadataId = "rescript-schema:String.refinements";

var Refinement = {
  metadataId: metadataId
};

function refinements(schema) {
  var m = schema.m[metadataId];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

var cuidRegex = /^c[^\s-]{8,}$/i;

var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;

var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;

var datetimeRe = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/;

function typeFilter$1(inputVar) {
  return "typeof " + inputVar + "!==\"string\"";
}

var schema$2 = makeWithNoopSerializer(primitiveName, "String", empty, noop, typeFilter$1);

var $$String = {
  Refinement: Refinement,
  refinements: refinements,
  cuidRegex: cuidRegex,
  uuidRegex: uuidRegex,
  emailRegex: emailRegex,
  datetimeRe: datetimeRe,
  typeFilter: typeFilter$1,
  schema: schema$2
};

function factory$4(schema, spaceOpt) {
  var space = spaceOpt !== undefined ? spaceOpt : 0;
  try {
    validateJsonableSchema(schema, schema, true);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    getOrRethrow(exn);
    var message = "The schema " + schema.n() + " passed to S.jsonString is not compatible with JSON";
    throw new Error("[rescript-schema] " + message);
  }
  return {
          r: "String",
          n: primitiveName,
          p: (function (b, input, param, path) {
              var jsonVal = allocateVal(b);
              b.c = b.c + ("try{" + set(b, jsonVal, map(b, "JSON.parse", input)) + "}catch(t){" + raiseWithArg(b, path, (function (message) {
                        return {
                                TAG: "OperationFailed",
                                _0: message
                              };
                      }), "t.message") + "}");
              var bb = scope(b);
              var val = parseWithTypeCheck(bb, schema, jsonVal, path);
              b.c = b.c + allocateScope(bb);
              return val;
            }),
          s: (function (b, input, param, path) {
              return val(b, "JSON.stringify(" + inline(b, schema.s(b, input, schema, path)) + (
                          space > 0 ? ",null," + space : ""
                        ) + ")");
            }),
          f: typeFilter$1,
          i: 0,
          m: empty
        };
}

var JsonString = {
  factory: factory$4
};

function typeFilter$2(inputVar) {
  return "typeof " + inputVar + "!==\"boolean\"";
}

var schema$3 = makeWithNoopSerializer(primitiveName, "Bool", empty, noop, typeFilter$2);

var Bool = {
  typeFilter: typeFilter$2,
  schema: schema$3
};

var metadataId$1 = "rescript-schema:Int.refinements";

var Refinement$1 = {
  metadataId: metadataId$1
};

function refinements$1(schema) {
  var m = schema.m[metadataId$1];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

function typeFilter$3(inputVar) {
  return "typeof " + inputVar + "!==\"number\"||" + inputVar + ">2147483647||" + inputVar + "<-2147483648||" + inputVar + "%1!==0";
}

var schema$4 = makeWithNoopSerializer(primitiveName, "Int", empty, noop, typeFilter$3);

var Int$1 = {
  Refinement: Refinement$1,
  refinements: refinements$1,
  typeFilter: typeFilter$3,
  schema: schema$4
};

var metadataId$2 = "rescript-schema:Float.refinements";

var Refinement$2 = {
  metadataId: metadataId$2
};

function refinements$2(schema) {
  var m = schema.m[metadataId$2];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

function typeFilter$4(inputVar) {
  return "typeof " + inputVar + "!==\"number\"||Number.isNaN(" + inputVar + ")";
}

var schema$5 = makeWithNoopSerializer(primitiveName, "Float", empty, noop, typeFilter$4);

var Float$2 = {
  Refinement: Refinement$2,
  refinements: refinements$2,
  typeFilter: typeFilter$4,
  schema: schema$5
};

var metadataId$3 = "rescript-schema:Array.refinements";

var Refinement$3 = {
  metadataId: metadataId$3
};

function refinements$3(schema) {
  var m = schema.m[metadataId$3];
  if (m !== undefined) {
    return m;
  } else {
    return [];
  }
}

function typeFilter$5(inputVar) {
  return "!Array.isArray(" + inputVar + ")";
}

function factory$5(schema) {
  return {
          r: {
            TAG: "Array",
            _0: schema
          },
          n: containerName,
          p: (function (b, input, param, path) {
              var inputVar = $$var(b, input);
              var iteratorVar = varWithoutAllocation(b);
              var bb = scope(b);
              var itemInput = val(bb, inputVar + "[" + iteratorVar + "]");
              var itemOutput = withPathPrepend(bb, itemInput, path, iteratorVar, (function (b, input, path) {
                      return parseWithTypeCheck(b, schema, input, path);
                    }));
              var itemCode = allocateScope(bb);
              var isTransformed = itemInput !== itemOutput;
              var output = isTransformed ? val(b, "[]") : input;
              b.c = b.c + ("for(let " + iteratorVar + "=0;" + iteratorVar + "<" + inputVar + ".length;++" + iteratorVar + "){" + itemCode + (
                  isTransformed ? push(b, output, itemOutput) : ""
                ) + "}");
              if (itemOutput.a) {
                return asyncVal(b, "()=>Promise.all(" + $$var(b, output) + ".map(t=>t()))");
              } else {
                return output;
              }
            }),
          s: (function (b, input, param, path) {
              if (schema.s === noop) {
                return input;
              }
              var inputVar = $$var(b, input);
              var iteratorVar = varWithoutAllocation(b);
              var output = val(b, "[]");
              var bb = scope(b);
              var itemOutput = withPathPrepend(bb, val(bb, inputVar + "[" + iteratorVar + "]"), path, iteratorVar, (function (b, input, path) {
                      return schema.s(b, input, schema, path);
                    }));
              var itemCode = allocateScope(bb);
              b.c = b.c + ("for(let " + iteratorVar + "=0;" + iteratorVar + "<" + inputVar + ".length;++" + iteratorVar + "){" + itemCode + push(b, output, itemOutput) + "}");
              return output;
            }),
          f: typeFilter$5,
          i: 0,
          m: empty
        };
}

var $$Array$1 = {
  Refinement: Refinement$3,
  refinements: refinements$3,
  typeFilter: typeFilter$5,
  factory: factory$5
};

function factory$6(schema) {
  return {
          r: {
            TAG: "Dict",
            _0: schema
          },
          n: containerName,
          p: (function (b, input, param, path) {
              var inputVar = $$var(b, input);
              var keyVar = varWithoutAllocation(b);
              var bb = scope(b);
              var itemInput = val(bb, inputVar + "[" + keyVar + "]");
              var itemOutput = withPathPrepend(bb, itemInput, path, keyVar, (function (b, input, path) {
                      return parseWithTypeCheck(b, schema, input, path);
                    }));
              var itemCode = allocateScope(bb);
              var isTransformed = itemInput !== itemOutput;
              var output = isTransformed ? val(b, "{}") : input;
              b.c = b.c + ("for(let " + keyVar + " in " + inputVar + "){" + itemCode + (
                  isTransformed ? addKey(b, output, keyVar, itemOutput) : ""
                ) + "}");
              if (!itemOutput.a) {
                return output;
              }
              var resolveVar = varWithoutAllocation(b);
              var rejectVar = varWithoutAllocation(b);
              var asyncParseResultVar = varWithoutAllocation(b);
              var counterVar = varWithoutAllocation(b);
              var outputVar = $$var(b, output);
              return asyncVal(b, "()=>new Promise((" + resolveVar + "," + rejectVar + ")=>{let " + counterVar + "=Object.keys(" + outputVar + ").length;for(let " + keyVar + " in " + outputVar + "){" + outputVar + "[" + keyVar + "]().then(" + asyncParseResultVar + "=>{" + outputVar + "[" + keyVar + "]=" + asyncParseResultVar + ";if(" + counterVar + "--===1){" + resolveVar + "(" + outputVar + ")}}," + rejectVar + ")}})");
            }),
          s: (function (b, input, param, path) {
              if (schema.s === noop) {
                return input;
              }
              var inputVar = $$var(b, input);
              var output = val(b, "{}");
              var keyVar = varWithoutAllocation(b);
              var bb = scope(b);
              var itemOutput = withPathPrepend(bb, val(bb, inputVar + "[" + keyVar + "]"), path, keyVar, (function (b, input, path) {
                      return schema.s(b, input, schema, path);
                    }));
              var itemCode = allocateScope(bb);
              b.c = b.c + ("for(let " + keyVar + " in " + inputVar + "){" + itemCode + addKey(b, output, keyVar, itemOutput) + "}");
              return output;
            }),
          f: typeFilter,
          i: 0,
          m: empty
        };
}

var Dict$1 = {
  factory: factory$6
};

function factory$7(definer) {
  var items = [];
  var item = function (idx, schema) {
    var $$location = idx.toString();
    var inlinedLocation = "\"" + $$location + "\"";
    if (items[idx]) {
      throw new Error("[rescript-schema] " + ("The item " + inlinedLocation + " is defined multiple times"));
    }
    var item_p = "[" + inlinedLocation + "]";
    var item$1 = {
      t: schema,
      p: item_p,
      l: $$location,
      i: inlinedLocation,
      s: itemSymbol
    };
    items[idx] = item$1;
    return item$1;
  };
  var tag = function (idx, asValue) {
    item(idx, literal(asValue));
  };
  var ctx = {
    item: item,
    tag: tag
  };
  var definition = definer(ctx);
  var length = items.length;
  for(var idx = 0; idx < length; ++idx){
    if (!items[idx]) {
      var $$location = idx.toString();
      var inlinedLocation = "\"" + $$location + "\"";
      var item_p = "[" + inlinedLocation + "]";
      var item$1 = {
        t: unit,
        p: item_p,
        l: $$location,
        i: inlinedLocation,
        s: itemSymbol
      };
      items[idx] = item$1;
    }
    
  }
  return {
          r: {
            TAG: "Tuple",
            items: items,
            definition: definition
          },
          n: (function () {
              return "Tuple(" + items.map(function (i) {
                            return i.t.n();
                          }).join(", ") + ")";
            }),
          p: parseOperationBuilder$1,
          s: serializeOperationBuilder$1,
          f: (function (inputVar) {
              return typeFilter$5(inputVar) + ("||" + inputVar + ".length!==" + length);
            }),
          i: 0,
          m: empty
        };
}

var Tuple = {
  factory: factory$7
};

function factory$8(schemas) {
  var len = schemas.length;
  if (len === 1) {
    return schemas[0];
  }
  if (len !== 0) {
    return {
            r: {
              TAG: "Union",
              _0: schemas
            },
            n: (function () {
                return "Union(" + schemas.map(function (s) {
                              return s.n();
                            }).join(", ") + ")";
              }),
            p: (function (b, input, selfSchema, path) {
                var schemas = selfSchema.r._0;
                var output = allocateVal(b);
                var codeEndRef = "";
                var errorCodeRef = "";
                var isAsync = false;
                for(var idx = 0 ,idx_finish = schemas.length; idx < idx_finish; ++idx){
                  var prevCode = b.c;
                  try {
                    var schema = schemas[idx];
                    var errorVar = "e" + idx;
                    b.c = b.c + "try{";
                    var itemOutput = parseWithTypeCheck(b, schema, input, "");
                    if (itemOutput.a) {
                      isAsync = true;
                    }
                    b.c = b.c + (set(b, output, itemOutput) + "}catch(" + errorVar + "){");
                    codeEndRef = codeEndRef + "}";
                    errorCodeRef = errorCodeRef + errorVar + ",";
                  }
                  catch (raw_exn){
                    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    var value = getOrRethrow(exn);
                    errorCodeRef = errorCodeRef + ("e[" + (b.g.e.push(value) - 1) + "]") + ",";
                    b.c = prevCode;
                  }
                }
                if (isAsync) {
                  invalidOperation(b, path, "S.union doesn't support async items. Please create an issue to rescript-schema if you nead the feature");
                }
                b.c = b.c + raiseWithArg(b, path, (function (internalErrors) {
                        return {
                                TAG: "InvalidUnion",
                                _0: internalErrors
                              };
                      }), "[" + errorCodeRef + "]") + codeEndRef;
                var isAllSchemasBuilderFailed = codeEndRef === "";
                if (isAllSchemasBuilderFailed) {
                  b.c = b.c + ";";
                  return input;
                } else {
                  return output;
                }
              }),
            s: (function (b, input, selfSchema, path) {
                var schemas = selfSchema.r._0;
                var output = allocateVal(b);
                var codeEndRef = "";
                var errorCodeRef = "";
                for(var idx = 0 ,idx_finish = schemas.length; idx < idx_finish; ++idx){
                  var prevCode = b.c;
                  try {
                    var schema = schemas[idx];
                    var errorVar = "e" + idx;
                    var bb = scope(b);
                    var itemOutput = schema.s(bb, input, schema, "");
                    b.c = b.c + ("try{" + allocateScope(bb));
                    var typeFilter = schema.f;
                    if (typeFilter !== undefined) {
                      var code = typeFilterCode(b, typeFilter, schema, itemOutput, "");
                      b.c = b.c + code;
                    }
                    b.c = b.c + (set(b, output, itemOutput) + "}catch(" + errorVar + "){");
                    codeEndRef = codeEndRef + "}";
                    errorCodeRef = errorCodeRef + errorVar + ",";
                  }
                  catch (raw_exn){
                    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    var value = getOrRethrow(exn);
                    errorCodeRef = errorCodeRef + ("e[" + (b.g.e.push(value) - 1) + "]") + ",";
                    b.c = prevCode;
                  }
                }
                b.c = b.c + raiseWithArg(b, path, (function (internalErrors) {
                        return {
                                TAG: "InvalidUnion",
                                _0: internalErrors
                              };
                      }), "[" + errorCodeRef + "]") + codeEndRef;
                var isAllSchemasBuilderFailed = codeEndRef === "";
                if (isAllSchemasBuilderFailed) {
                  b.c = b.c + ";";
                  return input;
                } else {
                  return output;
                }
              }),
            i: 0,
            m: empty
          };
  }
  throw new Error("[rescript-schema] S.union requires at least one item");
}

var Union = {
  factory: factory$8
};

function list(schema) {
  return transform$1(factory$5(schema), (function (param) {
                return {
                        p: Belt_List.fromArray,
                        s: Belt_List.toArray
                      };
              }));
}

function json(validate) {
  return makeWithNoopSerializer(primitiveName, {
              TAG: "JSON",
              validated: validate
            }, empty, validate ? (function (b, input, selfSchema, path) {
                  var parse = function (input, pathOpt) {
                    var path$1 = pathOpt !== undefined ? pathOpt : path;
                    var match = typeof input;
                    if (match === "string" || match === "boolean") {
                      return input;
                    }
                    if (match === "object") {
                      if (input === null) {
                        return input;
                      }
                      if (Array.isArray(input)) {
                        var output = [];
                        for(var idx = 0 ,idx_finish = input.length; idx < idx_finish; ++idx){
                          var inputItem = input[idx];
                          var $$location = idx.toString();
                          output.push(parse(inputItem, path$1 + ("[" + JSON.stringify($$location) + "]")));
                        }
                        return output;
                      }
                      var keys = Object.keys(input);
                      var output$1 = {};
                      for(var idx$1 = 0 ,idx_finish$1 = keys.length; idx$1 < idx_finish$1; ++idx$1){
                        var key = keys[idx$1];
                        var field = input[key];
                        output$1[key] = parse(field, path$1 + ("[" + JSON.stringify(key) + "]"));
                      }
                      return output$1;
                    }
                    if (match === "number") {
                      if (!Number.isNaN(input)) {
                        return input;
                      }
                      throw new RescriptSchemaError({
                                TAG: "InvalidType",
                                expected: selfSchema,
                                received: input
                              }, "Parsing", path$1);
                    }
                    throw new RescriptSchemaError({
                              TAG: "InvalidType",
                              expected: selfSchema,
                              received: input
                            }, "Parsing", path$1);
                  };
                  return map(b, "e[" + (b.g.e.push(parse) - 1) + "]", input);
                }) : noop, undefined);
}

var Catch = {};

function $$catch(schema, getFallbackValue) {
  return {
          r: schema.r,
          n: schema.n,
          p: (function (b, input, selfSchema, path) {
              var inputVar = $$var(b, input);
              return withCatch(b, input, (function (b, errorVar) {
                            return val(b, "e[" + (b.g.e.push(function (input, internalError) {
                                              return getFallbackValue({
                                                          e: internalError,
                                                          i: input,
                                                          s: selfSchema,
                                                          f: (function (message, customPathOpt) {
                                                              var customPath = customPathOpt !== undefined ? customPathOpt : "";
                                                              throw new RescriptSchemaError({
                                                                        TAG: "OperationFailed",
                                                                        _0: message
                                                                      }, b.g.o, path + customPath);
                                                            })
                                                        });
                                            }) - 1) + "](" + inputVar + "," + errorVar + ")");
                          }), (function (b) {
                            return parseWithTypeCheck(b, schema, input, path);
                          }));
            }),
          s: schema.s,
          i: 0,
          m: schema.m
        };
}

var deprecationMetadataId = "rescript-schema:deprecation";

function deprecate(schema, message) {
  return set$2(schema, deprecationMetadataId, message);
}

function deprecation(schema) {
  return schema.m[deprecationMetadataId];
}

var descriptionMetadataId = "rescript-schema:description";

function describe(schema, description) {
  return set$2(schema, descriptionMetadataId, description);
}

function description(schema) {
  return schema.m[descriptionMetadataId];
}

function definitionToSchema(definition, embededSet) {
  if (embededSet.has(definition)) {
    return definition;
  } else if (typeof definition === "object" && definition !== null) {
    if (Array.isArray(definition)) {
      return factory$7(function (s) {
                  for(var idx = 0 ,idx_finish = definition.length; idx < idx_finish; ++idx){
                    var definition$1 = definition[idx];
                    definition[idx] = s.item(idx, definitionToSchema(definition$1, embededSet));
                  }
                  return definition;
                });
    } else {
      return factory$3(function (s) {
                  var objectDefinition = {};
                  var keys = Object.keys(definition);
                  for(var idx = 0 ,idx_finish = keys.length; idx < idx_finish; ++idx){
                    var key = keys[idx];
                    var definition$1 = definition[key];
                    objectDefinition[key] = s.f(key, definitionToSchema(definition$1, embededSet));
                  }
                  return objectDefinition;
                });
    }
  } else {
    return literal(definition);
  }
}

function factory$9(definer) {
  var embededSet = new WeakSet();
  var matches = function (schema) {
    embededSet.add(schema);
    return schema;
  };
  var ctx = {
    matches: matches
  };
  var definition = definer(ctx);
  return definitionToSchema(definition, embededSet);
}

var Schema = {
  definitionToSchema: definitionToSchema,
  factory: factory$9
};

var $$class = RescriptSchemaError;

function make$5(prim0, prim1, prim2) {
  return new RescriptSchemaError(prim0, prim1, prim2);
}

function raise$1(error) {
  throw error;
}

function reason(error, nestedLevelOpt) {
  var nestedLevel = nestedLevelOpt !== undefined ? nestedLevelOpt : 0;
  var reason$1 = error.code;
  if (typeof reason$1 !== "object") {
    return "Encountered unexpected asynchronous transform or refine. Use S.parseAsyncWith instead of S.parseWith";
  }
  switch (reason$1.TAG) {
    case "OperationFailed" :
        return reason$1._0;
    case "InvalidOperation" :
        return reason$1.description;
    case "InvalidType" :
        return "Expected " + reason$1.expected.n() + ", received " + parseInternal(reason$1.received).s;
    case "InvalidLiteral" :
        return "Expected " + reason$1.expected.s + ", received " + parseInternal(reason$1.received).s;
    case "ExcessField" :
        return "Encountered disallowed excess key " + JSON.stringify(reason$1._0) + " on an object. Use Deprecated to ignore a specific field, or S.Object.strip to ignore excess keys completely";
    case "InvalidUnion" :
        var lineBreak = "\n" + " ".repeat((nestedLevel << 1));
        var reasonsDict = {};
        reason$1._0.forEach(function (error) {
              var reason$2 = reason(error, nestedLevel + 1);
              var nonEmptyPath = error.path;
              var $$location = nonEmptyPath === "" ? "" : "Failed at " + nonEmptyPath + ". ";
              reasonsDict["- " + $$location + reason$2] = undefined;
            });
        var uniqueReasons = Object.keys(reasonsDict);
        return "Invalid union with following errors" + lineBreak + uniqueReasons.join(lineBreak);
    case "InvalidJsonStruct" :
        return "The schema " + reason$1._0.n() + " is not compatible with JSON";
    
  }
}

function message(error) {
  var match = error.operation;
  var operation;
  operation = match === "Parsing" ? "parsing" : "serializing";
  var nonEmptyPath = error.path;
  var pathText = nonEmptyPath === "" ? "root" : nonEmptyPath;
  return "Failed " + operation + " at " + pathText + ". Reason: " + reason(error);
}

var $$Error$1 = {
  $$class: $$class,
  make: make$5,
  raise: raise$1,
  reason: reason,
  message: message
};

function internalInline(schema, maybeVariant, param) {
  var metadataMap = Object.assign({}, schema.m);
  var literal = schema.r;
  var inlinedSchema;
  if (typeof literal !== "object") {
    switch (literal) {
      case "Never" :
          inlinedSchema = "S.never";
          break;
      case "Unknown" :
          inlinedSchema = "S.unknown";
          break;
      case "String" :
          inlinedSchema = "S.string";
          break;
      case "Int" :
          inlinedSchema = "S.int";
          break;
      case "Float" :
          inlinedSchema = "S.float";
          break;
      case "Bool" :
          inlinedSchema = "S.bool";
          break;
      
    }
  } else {
    switch (literal.TAG) {
      case "Literal" :
          inlinedSchema = "S.literal(%raw(\`" + literal._0.s + "\`))";
          break;
      case "Option" :
          inlinedSchema = "S.option(" + internalInline(literal._0, undefined, undefined) + ")";
          break;
      case "Null" :
          inlinedSchema = "S.null(" + internalInline(literal._0, undefined, undefined) + ")";
          break;
      case "Array" :
          inlinedSchema = "S.array(" + internalInline(literal._0, undefined, undefined) + ")";
          break;
      case "Object" :
          var items = literal.items;
          inlinedSchema = items.length !== 0 ? "S.object(s =>\n  {\n    " + items.map(function (item) {
                    return item.i + ": s.field(" + item.i + ", " + internalInline(item.t, undefined, undefined) + ")";
                  }).join(",\n    ") + ",\n  }\n)" : "S.object(_ => ())";
          break;
      case "Tuple" :
          var tupleSchemas = literal.items;
          var exit = 0;
          var len = tupleSchemas.length;
          if (len >= 4) {
            exit = 1;
          } else {
            switch (len) {
              case 0 :
                  exit = 1;
                  break;
              case 1 :
                  var i1 = tupleSchemas[0];
                  inlinedSchema = "S.tuple1(" + internalInline(i1.t, undefined, undefined) + ")";
                  break;
              case 2 :
                  var i1$1 = tupleSchemas[0];
                  var i2 = tupleSchemas[1];
                  inlinedSchema = "S.tuple2(" + internalInline(i1$1.t, undefined, undefined) + ", " + internalInline(i2.t, undefined, undefined) + ")";
                  break;
              case 3 :
                  var i1$2 = tupleSchemas[0];
                  var i2$1 = tupleSchemas[1];
                  var i3 = tupleSchemas[2];
                  inlinedSchema = "S.tuple3(" + internalInline(i1$2.t, undefined, undefined) + ", " + internalInline(i2$1.t, undefined, undefined) + ", " + internalInline(i3.t, undefined, undefined) + ")";
                  break;
              
            }
          }
          if (exit === 1) {
            inlinedSchema = "S.tuple(s => (" + tupleSchemas.map(function (item, idx) {
                    return "s.item(" + idx + ", " + internalInline(item.t, undefined, undefined) + ")";
                  }).join(", ") + "))";
          }
          break;
      case "Union" :
          var variantNamesCounter = {};
          inlinedSchema = "S.union([" + literal._0.map(function (s) {
                  var variantName = s.n();
                  var n = Js_dict.get(variantNamesCounter, variantName);
                  var numberOfVariantNames = n !== undefined ? n : 0;
                  variantNamesCounter[variantName] = numberOfVariantNames + 1;
                  var variantName$1 = numberOfVariantNames !== 0 ? variantName + (numberOfVariantNames + 1) : variantName;
                  var inlinedVariant = "#" + JSON.stringify(variantName$1);
                  return internalInline(s, inlinedVariant, undefined);
                }).join(", ") + "])";
          break;
      case "Dict" :
          inlinedSchema = "S.dict(" + internalInline(literal._0, undefined, undefined) + ")";
          break;
      case "JSON" :
          inlinedSchema = "S.json(~validate=" + literal.validated + ")";
          break;
      
    }
  }
  var $$default = schema.m[defaultMetadataId];
  var inlinedSchema$1;
  if ($$default !== undefined) {
    Js_dict.unsafeDeleteKey(metadataMap, defaultMetadataId);
    if ($$default.TAG === "Value") {
      var defaultValue = $$default._0;
      inlinedSchema$1 = inlinedSchema + ("->S.Option.getOr(%raw(\`" + (
          defaultValue === (void 0) ? "undefined" : JSON.stringify(defaultValue)
        ) + "\`))");
    } else {
      var any = $$default._0();
      inlinedSchema$1 = inlinedSchema + ("->S.Option.getOrWith(() => %raw(\`" + (
          any === (void 0) ? "undefined" : JSON.stringify(any)
        ) + "\`))");
    }
  } else {
    inlinedSchema$1 = inlinedSchema;
  }
  var message = deprecation(schema);
  var inlinedSchema$2 = message !== undefined ? (Js_dict.unsafeDeleteKey(metadataMap, deprecationMetadataId), inlinedSchema$1 + ("->S.deprecate(" + JSON.stringify(message) + ")")) : inlinedSchema$1;
  var message$1 = description(schema);
  var inlinedSchema$3 = message$1 !== undefined ? (Js_dict.unsafeDeleteKey(metadataMap, descriptionMetadataId), inlinedSchema$2 + ("->S.describe(" + (
          message$1 === (void 0) ? "undefined" : JSON.stringify(message$1)
        ) + ")")) : inlinedSchema$2;
  var match = schema.r;
  var inlinedSchema$4;
  inlinedSchema$4 = typeof match !== "object" || !(match.TAG === "Object" && match.unknownKeys !== "Strip") ? inlinedSchema$3 : inlinedSchema$3 + "->S.Object.strict";
  var match$1 = schema.r;
  var inlinedSchema$5;
  var exit$1 = 0;
  if (typeof match$1 !== "object") {
    switch (match$1) {
      case "String" :
          exit$1 = 1;
          break;
      case "Int" :
          var refinements$4 = refinements$1(schema);
          if (refinements$4.length !== 0) {
            Js_dict.unsafeDeleteKey(metadataMap, metadataId$1);
            inlinedSchema$5 = inlinedSchema$4 + refinements$4.map(function (refinement) {
                    var match = refinement.kind;
                    if (typeof match !== "object") {
                      return "->S.port(~message=" + JSON.stringify(refinement.message) + ")";
                    } else if (match.TAG === "Min") {
                      return "->S.intMin(" + match.value + ", ~message=" + JSON.stringify(refinement.message) + ")";
                    } else {
                      return "->S.intMax(" + match.value + ", ~message=" + JSON.stringify(refinement.message) + ")";
                    }
                  }).join("");
          } else {
            inlinedSchema$5 = inlinedSchema$4;
          }
          break;
      case "Float" :
          var refinements$5 = refinements$2(schema);
          if (refinements$5.length !== 0) {
            Js_dict.unsafeDeleteKey(metadataMap, metadataId$2);
            inlinedSchema$5 = inlinedSchema$4 + refinements$5.map(function (refinement) {
                    var match = refinement.kind;
                    if (match.TAG === "Min") {
                      var value = match.value;
                      return "->S.floatMin(" + (value.toString() + (
                                value % 1 === 0 ? "." : ""
                              )) + ", ~message=" + JSON.stringify(refinement.message) + ")";
                    }
                    var value$1 = match.value;
                    return "->S.floatMax(" + (value$1.toString() + (
                              value$1 % 1 === 0 ? "." : ""
                            )) + ", ~message=" + JSON.stringify(refinement.message) + ")";
                  }).join("");
          } else {
            inlinedSchema$5 = inlinedSchema$4;
          }
          break;
      default:
        inlinedSchema$5 = inlinedSchema$4;
    }
  } else {
    switch (match$1.TAG) {
      case "Literal" :
          if (match$1._0.kind === "String") {
            exit$1 = 1;
          } else {
            inlinedSchema$5 = inlinedSchema$4;
          }
          break;
      case "Array" :
          var refinements$6 = refinements$3(schema);
          if (refinements$6.length !== 0) {
            Js_dict.unsafeDeleteKey(metadataMap, metadataId$3);
            inlinedSchema$5 = inlinedSchema$4 + refinements$6.map(function (refinement) {
                    var match = refinement.kind;
                    switch (match.TAG) {
                      case "Min" :
                          return "->S.arrayMinLength(" + match.length + ", ~message=" + JSON.stringify(refinement.message) + ")";
                      case "Max" :
                          return "->S.arrayMaxLength(" + match.length + ", ~message=" + JSON.stringify(refinement.message) + ")";
                      case "Length" :
                          return "->S.arrayLength(" + match.length + ", ~message=" + JSON.stringify(refinement.message) + ")";
                      
                    }
                  }).join("");
          } else {
            inlinedSchema$5 = inlinedSchema$4;
          }
          break;
      default:
        inlinedSchema$5 = inlinedSchema$4;
    }
  }
  if (exit$1 === 1) {
    var refinements$7 = refinements(schema);
    if (refinements$7.length !== 0) {
      Js_dict.unsafeDeleteKey(metadataMap, metadataId);
      inlinedSchema$5 = inlinedSchema$4 + refinements$7.map(function (refinement) {
              var match = refinement.kind;
              if (typeof match !== "object") {
                switch (match) {
                  case "Email" :
                      return "->S.email(~message=" + JSON.stringify(refinement.message) + ")";
                  case "Uuid" :
                      return "->S.uuid(~message=" + JSON.stringify(refinement.message) + ")";
                  case "Cuid" :
                      return "->S.cuid(~message=" + JSON.stringify(refinement.message) + ")";
                  case "Url" :
                      return "->S.url(~message=" + JSON.stringify(refinement.message) + ")";
                  case "Datetime" :
                      return "->S.datetime(~message=" + JSON.stringify(refinement.message) + ")";
                  
                }
              } else {
                switch (match.TAG) {
                  case "Min" :
                      return "->S.stringMinLength(" + match.length + ", ~message=" + JSON.stringify(refinement.message) + ")";
                  case "Max" :
                      return "->S.stringMaxLength(" + match.length + ", ~message=" + JSON.stringify(refinement.message) + ")";
                  case "Length" :
                      return "->S.stringLength(" + match.length + ", ~message=" + JSON.stringify(refinement.message) + ")";
                  case "Pattern" :
                      return "->S.pattern(%re(" + JSON.stringify(match.re.toString()) + "), ~message=" + JSON.stringify(refinement.message) + ")";
                  
                }
              }
            }).join("");
    } else {
      inlinedSchema$5 = inlinedSchema$4;
    }
  }
  var inlinedSchema$6 = Object.keys(metadataMap).length !== 0 ? "{\n  let s = " + inlinedSchema$5 + "\n  let _ = %raw(\`s.m = " + JSON.stringify(metadataMap) + "\`)\n  s\n}" : inlinedSchema$5;
  if (maybeVariant !== undefined) {
    return inlinedSchema$6 + ("->S.variant(v => " + maybeVariant + "(v))");
  } else {
    return inlinedSchema$6;
  }
}

function inline$1(schema) {
  return internalInline(schema, undefined, undefined);
}

function tuple1(v0) {
  return factory$7(function (s) {
              return s.item(0, v0);
            });
}

function tuple2(v0, v1) {
  return factory$7(function (s) {
              return [
                      s.item(0, v0),
                      s.item(1, v1)
                    ];
            });
}

function tuple3(v0, v1, v2) {
  return factory$7(function (s) {
              return [
                      s.item(0, v0),
                      s.item(1, v1),
                      s.item(2, v2)
                    ];
            });
}

function intMin(schema, minValue, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "Number must be greater than or equal to " + minValue;
  return addRefinement(schema, metadataId$1, {
              kind: {
                TAG: "Min",
                value: minValue
              },
              message: message
            }, (function (b, input, param, path) {
                return "if(" + $$var(b, input) + "<" + ("e[" + (b.g.e.push(minValue) - 1) + "]") + "){" + fail(b, message, path) + "}";
              }));
}

function intMax(schema, maxValue, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "Number must be lower than or equal to " + maxValue;
  return addRefinement(schema, metadataId$1, {
              kind: {
                TAG: "Max",
                value: maxValue
              },
              message: message
            }, (function (b, input, param, path) {
                return "if(" + $$var(b, input) + ">" + ("e[" + (b.g.e.push(maxValue) - 1) + "]") + "){" + fail(b, message, path) + "}";
              }));
}

function port(schema, messageOpt) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid port";
  return addRefinement(schema, metadataId$1, {
              kind: "Port",
              message: message
            }, (function (b, input, param, path) {
                return "if(" + $$var(b, input) + "<1||" + $$var(b, input) + ">65535){" + fail(b, message, path) + "}";
              }));
}

function floatMin(schema, minValue, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "Number must be greater than or equal to " + minValue;
  return addRefinement(schema, metadataId$2, {
              kind: {
                TAG: "Min",
                value: minValue
              },
              message: message
            }, (function (b, input, param, path) {
                return "if(" + $$var(b, input) + "<" + ("e[" + (b.g.e.push(minValue) - 1) + "]") + "){" + fail(b, message, path) + "}";
              }));
}

function floatMax(schema, maxValue, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "Number must be lower than or equal to " + maxValue;
  return addRefinement(schema, metadataId$2, {
              kind: {
                TAG: "Max",
                value: maxValue
              },
              message: message
            }, (function (b, input, param, path) {
                return "if(" + $$var(b, input) + ">" + ("e[" + (b.g.e.push(maxValue) - 1) + "]") + "){" + fail(b, message, path) + "}";
              }));
}

function arrayMinLength(schema, length, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "Array must be " + length + " or more items long";
  return addRefinement(schema, metadataId$3, {
              kind: {
                TAG: "Min",
                length: length
              },
              message: message
            }, (function (b, input, param, path) {
                return "if(" + $$var(b, input) + ".length<" + ("e[" + (b.g.e.push(length) - 1) + "]") + "){" + fail(b, message, path) + "}";
              }));
}

function arrayMaxLength(schema, length, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "Array must be " + length + " or fewer items long";
  return addRefinement(schema, metadataId$3, {
              kind: {
                TAG: "Max",
                length: length
              },
              message: message
            }, (function (b, input, param, path) {
                return "if(" + $$var(b, input) + ".length>" + ("e[" + (b.g.e.push(length) - 1) + "]") + "){" + fail(b, message, path) + "}";
              }));
}

function arrayLength(schema, length, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "Array must be exactly " + length + " items long";
  return addRefinement(schema, metadataId$3, {
              kind: {
                TAG: "Length",
                length: length
              },
              message: message
            }, (function (b, input, param, path) {
                return "if(" + $$var(b, input) + ".length!==" + ("e[" + (b.g.e.push(length) - 1) + "]") + "){" + fail(b, message, path) + "}";
              }));
}

function stringMinLength(schema, length, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "String must be " + length + " or more characters long";
  return addRefinement(schema, metadataId, {
              kind: {
                TAG: "Min",
                length: length
              },
              message: message
            }, (function (b, input, param, path) {
                return "if(" + $$var(b, input) + ".length<" + ("e[" + (b.g.e.push(length) - 1) + "]") + "){" + fail(b, message, path) + "}";
              }));
}

function stringMaxLength(schema, length, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "String must be " + length + " or fewer characters long";
  return addRefinement(schema, metadataId, {
              kind: {
                TAG: "Max",
                length: length
              },
              message: message
            }, (function (b, input, param, path) {
                return "if(" + $$var(b, input) + ".length>" + ("e[" + (b.g.e.push(length) - 1) + "]") + "){" + fail(b, message, path) + "}";
              }));
}

function stringLength(schema, length, maybeMessage) {
  var message = maybeMessage !== undefined ? maybeMessage : "String must be exactly " + length + " characters long";
  return addRefinement(schema, metadataId, {
              kind: {
                TAG: "Length",
                length: length
              },
              message: message
            }, (function (b, input, param, path) {
                return "if(" + $$var(b, input) + ".length!==" + ("e[" + (b.g.e.push(length) - 1) + "]") + "){" + fail(b, message, path) + "}";
              }));
}

function email(schema, messageOpt) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid email address";
  return addRefinement(schema, metadataId, {
              kind: "Email",
              message: message
            }, (function (b, input, param, path) {
                return "if(!" + ("e[" + (b.g.e.push(emailRegex) - 1) + "]") + ".test(" + $$var(b, input) + ")){" + fail(b, message, path) + "}";
              }));
}

function uuid(schema, messageOpt) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid UUID";
  return addRefinement(schema, metadataId, {
              kind: "Uuid",
              message: message
            }, (function (b, input, param, path) {
                return "if(!" + ("e[" + (b.g.e.push(uuidRegex) - 1) + "]") + ".test(" + $$var(b, input) + ")){" + fail(b, message, path) + "}";
              }));
}

function cuid(schema, messageOpt) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid CUID";
  return addRefinement(schema, metadataId, {
              kind: "Cuid",
              message: message
            }, (function (b, input, param, path) {
                return "if(!" + ("e[" + (b.g.e.push(cuidRegex) - 1) + "]") + ".test(" + $$var(b, input) + ")){" + fail(b, message, path) + "}";
              }));
}

function url(schema, messageOpt) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid url";
  return addRefinement(schema, metadataId, {
              kind: "Url",
              message: message
            }, (function (b, input, param, path) {
                return "try{new URL(" + $$var(b, input) + ")}catch(_){" + fail(b, message, path) + "}";
              }));
}

function pattern(schema, re, messageOpt) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid";
  return addRefinement(schema, metadataId, {
              kind: {
                TAG: "Pattern",
                re: re
              },
              message: message
            }, (function (b, input, param, path) {
                var reVal = val(b, "e[" + (b.g.e.push(re) - 1) + "]");
                var reVar = $$var(b, reVal);
                return reVar + ".lastIndex=0;if(!" + reVar + ".test(" + $$var(b, input) + ")){" + fail(b, message, path) + "}";
              }));
}

function datetime(schema, messageOpt) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid datetime string! Must be UTC";
  var refinement = {
    kind: "Datetime",
    message: message
  };
  var refinements = schema.m[metadataId];
  return transform$1(set$2(schema, metadataId, refinements !== undefined ? refinements.concat(refinement) : [refinement]), (function (s) {
                return {
                        p: (function (string) {
                            if (!datetimeRe.test(string)) {
                              s.fail(message, undefined);
                            }
                            return new Date(string);
                          }),
                        s: (function (date) {
                            return date.toISOString();
                          })
                      };
              }));
}

function trim(schema) {
  var transformer = function (string) {
    return string.trim();
  };
  return transform$1(schema, (function (param) {
                return {
                        p: transformer,
                        s: transformer
                      };
              }));
}

function toJsResult(result) {
  if (result.TAG === "Ok") {
    return {
            success: true,
            value: result._0
          };
  } else {
    return {
            success: false,
            error: result._0
          };
  }
}

function js_parse(schema, data) {
  try {
    return {
            success: true,
            value: parseAnyOrRaiseWith(data, schema)
          };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    return {
            success: false,
            error: getOrRethrow(exn)
          };
  }
}

function js_parseOrThrow(schema, data) {
  return parseAnyOrRaiseWith(data, schema);
}

function js_parseAsync(schema, data) {
  return parseAnyAsyncWith(data, schema).then(toJsResult);
}

function js_serialize(schema, value) {
  try {
    return {
            success: true,
            value: serializeToUnknownOrRaiseWith(value, schema)
          };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    return {
            success: false,
            error: getOrRethrow(exn)
          };
  }
}

function js_serializeOrThrow(schema, value) {
  return serializeToUnknownOrRaiseWith(value, schema);
}

function js_transform(schema, maybeParser, maybeSerializer) {
  return transform$1(schema, (function (s) {
                return {
                        p: maybeParser !== undefined ? (function (v) {
                              return maybeParser(v, s);
                            }) : undefined,
                        s: maybeSerializer !== undefined ? (function (v) {
                              return maybeSerializer(v, s);
                            }) : undefined
                      };
              }));
}

function js_refine(schema, refiner) {
  return refine(schema, (function (s) {
                return function (v) {
                  refiner(v, s);
                };
              }));
}

function noop$1(a) {
  return a;
}

function js_asyncParserRefine(schema, refine) {
  return transform$1(schema, (function (s) {
                return {
                        a: (function (v) {
                            return function () {
                              return refine(v, s).then(function () {
                                          return v;
                                        });
                            };
                          }),
                        s: noop$1
                      };
              }));
}

function js_optional(schema, maybeOr) {
  var schema$1 = factory$1(schema);
  if (maybeOr === undefined) {
    return schema$1;
  }
  var or = Caml_option.valFromOption(maybeOr);
  if (typeof or === "function") {
    return getOrWith(schema$1, or);
  } else {
    return getOr(schema$1, or);
  }
}

function js_tuple(definer) {
  if (typeof definer === "function") {
    return factory$7(definer);
  } else {
    return factory$7(function (s) {
                return definer.map(function (schema, idx) {
                            return s.item(idx, schema);
                          });
              });
  }
}

function js_custom(name, maybeParser, maybeSerializer, param) {
  return custom(name, (function (s) {
                return {
                        p: maybeParser !== undefined ? (function (v) {
                              return maybeParser(v, s);
                            }) : undefined,
                        s: maybeSerializer !== undefined ? (function (v) {
                              return maybeSerializer(v, s);
                            }) : undefined
                      };
              }));
}

function js_object(definer) {
  if (typeof definer === "function") {
    return factory$3(definer);
  } else {
    return factory$3(function (s) {
                var definition = {};
                var fieldNames = Object.keys(definer);
                for(var idx = 0 ,idx_finish = fieldNames.length; idx < idx_finish; ++idx){
                  var fieldName = fieldNames[idx];
                  var schema = definer[fieldName];
                  definition[fieldName] = s.f(fieldName, schema);
                }
                return definition;
              });
  }
}

function js_merge(s1, s2) {
  var match = s1.r;
  if (typeof match === "object" && match.TAG === "Object") {
    var s1Items = match.items;
    var match$1 = s2.r;
    if (typeof match$1 === "object" && match$1.TAG === "Object") {
      var s2Items = match$1.items;
      var items = [];
      var fields = {};
      for(var idx = 0 ,idx_finish = s1Items.length; idx < idx_finish; ++idx){
        var item = s1Items[idx];
        items.push(item);
        fields[item.l] = item;
      }
      for(var idx$1 = 0 ,idx_finish$1 = s2Items.length; idx$1 < idx_finish$1; ++idx$1){
        var item$1 = s2Items[idx$1];
        if (fields[item$1.l]) {
          throw new Error("[rescript-schema] " + ("The field " + item$1.i + " is defined multiple times"));
        }
        items.push(item$1);
        fields[item$1.l] = item$1;
      }
      return {
              r: {
                TAG: "Object",
                items: items,
                fields: fields,
                unknownKeys: match$1.unknownKeys,
                definition: (void 0)
              },
              n: (function () {
                  return s1.n() + " & " + s2.n();
                }),
              p: (function (b, input, param, path) {
                  var s1Result = s1.p(b, input, s1, path);
                  var s2Result = s2.p(b, input, s2, path);
                  return val(b, "Object.assign(" + inline(b, s1Result) + ", " + inline(b, s2Result) + ")");
                }),
              s: (function (b, param, param$1, path) {
                  return invalidOperation(b, path, "The S.merge serializing is not supported yet");
                }),
              f: typeFilter,
              i: 0,
              m: empty
            };
    }
    
  }
  throw new Error("[rescript-schema] The merge supports only Object schemas");
}

function js_name(prim) {
  return prim.n();
}

var B$1;

var parseWith = parseAnyWith;

var parseOrRaiseWith = parseAnyOrRaiseWith;

var parseAsyncWith = parseAnyAsyncWith;

var parseAsyncInStepsWith = parseAnyAsyncInStepsWith;

var schema$6 = factory$9;

var object$1 = factory$3;

var never = schema;

var unknown = schema$1;

var string$1 = schema$2;

var bool = schema$3;

var $$int = schema$4;

var $$float = schema$5;

var $$null$1 = factory$2;

var option = factory$1;

var array$1 = factory$5;

var dict$1 = factory$6;

var variant = factory;

var tuple = factory$7;

var union = factory$8;

var jsonString = factory$4;

export {
  Obj ,
  Stdlib ,
  Path ,
  symbol ,
  itemSymbol ,
  Raised ,
  unsafeGetVariantPayload ,
  unsafeGetErrorPayload ,
  InternalError ,
  EffectCtx ,
  classify ,
  Builder ,
  B$1 as B,
  Literal ,
  isAsyncParse ,
  validateJsonableSchema ,
  make$2 as make,
  makeWithNoopSerializer ,
  Operation ,
  parseAnyOrRaiseWith ,
  parseAnyWith ,
  parseWith ,
  parseOrRaiseWith ,
  asyncPrepareOk ,
  asyncPrepareError ,
  internalParseAsyncWith ,
  parseAnyAsyncWith ,
  parseAsyncWith ,
  parseAnyAsyncInStepsWith ,
  parseAsyncInStepsWith ,
  serializeOrRaiseWith ,
  serializeWith ,
  serializeToUnknownOrRaiseWith ,
  serializeToUnknownWith ,
  serializeToJsonStringWith ,
  serializeToJsonStringOrRaiseWith ,
  parseJsonStringWith ,
  Metadata ,
  recursive ,
  setName ,
  primitiveName ,
  containerName ,
  internalRefine ,
  refine ,
  addRefinement ,
  transform$1 as transform,
  preprocess ,
  custom ,
  literal ,
  unit ,
  Definition ,
  Variant ,
  $$Option ,
  Null ,
  nullable ,
  Never ,
  $$Object$1 as $$Object,
  Unknown ,
  $$String ,
  JsonString ,
  Bool ,
  Int$1 as Int,
  Float$2 as Float,
  $$Array$1 as $$Array,
  Dict$1 as Dict,
  Tuple ,
  Union ,
  list ,
  json ,
  Catch ,
  $$catch ,
  deprecationMetadataId ,
  deprecate ,
  deprecation ,
  descriptionMetadataId ,
  describe ,
  description ,
  Schema ,
  schema$6 as schema,
  $$Error$1 as $$Error,
  inline$1 as inline,
  object$1 as object,
  never ,
  unknown ,
  string$1 as string,
  bool ,
  $$int ,
  $$float ,
  $$null$1 as $$null,
  option ,
  array$1 as array,
  dict$1 as dict,
  variant ,
  tuple ,
  tuple1 ,
  tuple2 ,
  tuple3 ,
  union ,
  jsonString ,
  intMin ,
  intMax ,
  port ,
  floatMin ,
  floatMax ,
  arrayMinLength ,
  arrayMaxLength ,
  arrayLength ,
  stringMinLength ,
  stringMaxLength ,
  stringLength ,
  email ,
  uuid ,
  cuid ,
  url ,
  pattern ,
  datetime ,
  trim ,
  toJsResult ,
  js_parse ,
  js_parseOrThrow ,
  js_parseAsync ,
  js_serialize ,
  js_serializeOrThrow ,
  js_transform ,
  js_refine ,
  noop$1 as noop,
  js_asyncParserRefine ,
  js_optional ,
  js_tuple ,
  js_custom ,
  js_object ,
  js_merge ,
  js_name ,
}
/* symbol Not a pure module */
